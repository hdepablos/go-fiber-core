
// Obtenemos los elementos del DOM
const startButton = document.getElementById('startButton');
const cancelButton = document.getElementById('cancelButton');
const statusDiv = document.getElementById('status');

// Declaramos el controlador en un scope accesible por ambas funciones
let abortController;

// Funci√≥n para iniciar la petici√≥n
const startRequest = async () => {
    // 1. Creamos un nuevo controlador para cada petici√≥n
    abortController = new AbortController();
    const signal = abortController.signal;

    // Actualizamos la UI para indicar que el proceso comenz√≥
    statusDiv.textContent = 'Petici√≥n en curso...';
    startButton.disabled = true;
    cancelButton.disabled = false;

    try {
        // 2. Hacemos la petici√≥n y pasamos el 'signal' en el objeto de configuraci√≥n
        const response = await axios.get('https://jsonplaceholder.typicode.com/users', {
            signal: signal
        });
        
        statusDiv.textContent = `√âxito: Se encontraron ${response.data.length} usuarios.`;
        console.log(response.data);

    } catch (error) {
        // 4. Axios tiene un helper para saber si el error fue por cancelaci√≥n
        if (axios.isCancel(error)) {
            statusDiv.textContent = 'La petici√≥n fue cancelada por el usuario.';
            console.log('Error de cancelaci√≥n:', error.message);
        } else {
            // Manejo de otros errores (de red, etc.)
            statusDiv.textContent = 'Ocurri√≥ un error en la petici√≥n.';
            console.error('Error de Axios:', error);
        }
    } finally {
        // Se ejecuta siempre, ya sea por √©xito, cancelaci√≥n u otro error
        startButton.disabled = false;
        cancelButton.disabled = true;
    }
};

// Funci√≥n para cancelar la petici√≥n
const cancelRequest = () => {
    if (abortController) {
        // 3. Llamamos a .abort() para cancelar
        abortController.abort();
    }
};

// Asignamos las funciones a los eventos de los botones
startButton.addEventListener('click', startRequest);
cancelButton.addEventListener('click', cancelRequest);



package main

import(
    "log"
	"time"

	"github.com/gofiber/fiber/v2"
)

func devolucionesHandler(c * fiber.Ctx) error {
    log.Println("‚úÖ Petici√≥n recibida...")

    // Aqu√≠ est√° el "receptor" de la se√±al de cancelaci√≥n del cliente.
    // Fiber nos da acceso al context.Context est√°ndar de Go.
    ctx:= c.UserContext()

	select {
	case < -time.After(10 * time.Second):
        // Este bloque se ejecuta si la tarea termina antes de que el cliente cancele.
        log.Println("üëç Tarea completada.")
        return c.SendString("Proceso completado.")

	// ESTA ES LA PARTE CLAVE:
	case < -ctx.Done():
        // Esta l√≠nea se activa CUANDO el cliente cierra la conexi√≥n (por el AbortController).
        // El canal `ctx.Done()` se cierra, lo que desbloquea este 'case'.
        log.Println("üö´ Conexi√≥n cerrada por el cliente. Cancelando tarea.")

        // Detenemos el trabajo y retornamos.
        return nil
    }
}

func main() {
    app:= fiber.New()
    app.Get("/devoluciones", devolucionesHandler)

    log.Println("üöÄ Servidor Fiber escuchando en http://localhost:8080")
    log.Fatal(app.Listen(":8080"))
}