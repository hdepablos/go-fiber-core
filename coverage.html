
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">

				<option value="file0">go-fiber-core/cmd/api/main.go (0.0%)</option>

				<option value="file1">go-fiber-core/cmd/cmd-cli/cmd/createUser.go (0.0%)</option>

				<option value="file2">go-fiber-core/cmd/cmd-cli/cmd/jobproducer.go (0.0%)</option>

				<option value="file3">go-fiber-core/cmd/cmd-cli/cmd/migrations.go (0.0%)</option>

				<option value="file4">go-fiber-core/cmd/cmd-cli/cmd/reversal.go (0.0%)</option>

				<option value="file5">go-fiber-core/cmd/cmd-cli/cmd/root.go (0.0%)</option>

				<option value="file6">go-fiber-core/cmd/cmd-cli/cmd/seed.go (0.0%)</option>

				<option value="file7">go-fiber-core/cmd/cmd-cli/cmd/sendemail.go (0.0%)</option>

				<option value="file8">go-fiber-core/cmd/cmd-cli/cmd/serviceconfigall.go (0.0%)</option>

				<option value="file9">go-fiber-core/cmd/cmd-cli/cmd/serviceconfigonly.go (0.0%)</option>

				<option value="file10">go-fiber-core/cmd/cmd-cli/main.go (0.0%)</option>

				<option value="file11">go-fiber-core/cmd/worker/main.go (0.0%)</option>

				<option value="file12">go-fiber-core/internal/adapters/backoffice_adapter.go (100.0%)</option>

				<option value="file13">go-fiber-core/internal/adapters/discord_adapter.go (0.0%)</option>

				<option value="file14">go-fiber-core/internal/appconfig/app_config.go (0.0%)</option>

				<option value="file15">go-fiber-core/internal/appconfig/viper_loader.go (0.0%)</option>

				<option value="file16">go-fiber-core/internal/cronjobs/tasks.go (0.0%)</option>

				<option value="file17">go-fiber-core/internal/database/connections/gorm/gorm_connect.go (0.0%)</option>

				<option value="file18">go-fiber-core/internal/database/connections/pgx/pgx_connect.go (0.0%)</option>

				<option value="file19">go-fiber-core/internal/database/connections/redis/redis_connect.go (0.0%)</option>

				<option value="file20">go-fiber-core/internal/database/database.go (0.0%)</option>

				<option value="file21">go-fiber-core/internal/database/factories/bulk_process_details_factory.go (0.0%)</option>

				<option value="file22">go-fiber-core/internal/database/factories/bulk_process_factory.go (0.0%)</option>

				<option value="file23">go-fiber-core/internal/database/migrations/migrations.go (0.0%)</option>

				<option value="file24">go-fiber-core/internal/database/models/bulk_process.go (0.0%)</option>

				<option value="file25">go-fiber-core/internal/database/models/bulk_process_detail.go (0.0%)</option>

				<option value="file26">go-fiber-core/internal/database/seeders/bank_seeder.go (0.0%)</option>

				<option value="file27">go-fiber-core/internal/database/seeders/bulk_process_seeder.go (0.0%)</option>

				<option value="file28">go-fiber-core/internal/database/seeders/seed_service.go (0.0%)</option>

				<option value="file29">go-fiber-core/internal/dtos/responses/response.go (0.0%)</option>

				<option value="file30">go-fiber-core/internal/handlers/auth_handler.go (78.6%)</option>

				<option value="file31">go-fiber-core/internal/handlers/bank_handler.go (39.1%)</option>

				<option value="file32">go-fiber-core/internal/handlers/database_handlers.go (0.0%)</option>

				<option value="file33">go-fiber-core/internal/handlers/user_handler.go (28.6%)</option>

				<option value="file34">go-fiber-core/internal/jobqueue/dispatcher.go (0.0%)</option>

				<option value="file35">go-fiber-core/internal/jobqueue/handlers.go (0.0%)</option>

				<option value="file36">go-fiber-core/internal/jobqueue/job.go (0.0%)</option>

				<option value="file37">go-fiber-core/internal/logger/logger.go (0.0%)</option>

				<option value="file38">go-fiber-core/internal/middleware/auth_middleware.go (100.0%)</option>

				<option value="file39">go-fiber-core/internal/middleware/error_handler.go (0.0%)</option>

				<option value="file40">go-fiber-core/internal/middleware/rate_limit_middleware.go (90.5%)</option>

				<option value="file41">go-fiber-core/internal/models/bank.go (0.0%)</option>

				<option value="file42">go-fiber-core/internal/models/refresh_token.go (0.0%)</option>

				<option value="file43">go-fiber-core/internal/models/user.go (0.0%)</option>

				<option value="file44">go-fiber-core/internal/repositories/bank/bank_pagination_repository.go (0.0%)</option>

				<option value="file45">go-fiber-core/internal/repositories/bank/bank_repository.go (0.0%)</option>

				<option value="file46">go-fiber-core/internal/repositories/refreshtoken/refreshtoken_repository.go (0.0%)</option>

				<option value="file47">go-fiber-core/internal/repositories/user/user_pagination_repository.go (0.0%)</option>

				<option value="file48">go-fiber-core/internal/repositories/user/user_repository.go (0.0%)</option>

				<option value="file49">go-fiber-core/internal/routes/auth_routes.go (0.0%)</option>

				<option value="file50">go-fiber-core/internal/routes/bank_routes.go (0.0%)</option>

				<option value="file51">go-fiber-core/internal/routes/database_routes.go (0.0%)</option>

				<option value="file52">go-fiber-core/internal/routes/user_routes.go (0.0%)</option>

				<option value="file53">go-fiber-core/internal/server/register_routes.go (0.0%)</option>

				<option value="file54">go-fiber-core/internal/server/server.go (0.0%)</option>

				<option value="file55">go-fiber-core/internal/services/auth/auth_service.go (75.6%)</option>

				<option value="file56">go-fiber-core/internal/services/auth/token_service.go (0.0%)</option>

				<option value="file57">go-fiber-core/internal/services/bank/bank_service.go (50.0%)</option>

				<option value="file58">go-fiber-core/internal/services/blacklist_bank_service.go (0.0%)</option>

				<option value="file59">go-fiber-core/internal/services/databases.go (0.0%)</option>

				<option value="file60">go-fiber-core/internal/services/email/email_service.go (0.0%)</option>

				<option value="file61">go-fiber-core/internal/services/email/typesemail/contact_sender.go (0.0%)</option>

				<option value="file62">go-fiber-core/internal/services/loanrisk/age.go (0.0%)</option>

				<option value="file63">go-fiber-core/internal/services/loanrisk/isrenovation.go (0.0%)</option>

				<option value="file64">go-fiber-core/internal/services/loanrisk/risklevel.go (0.0%)</option>

				<option value="file65">go-fiber-core/internal/services/loanrisk/salary.go (0.0%)</option>

				<option value="file66">go-fiber-core/internal/services/pagination/pagination.go (83.5%)</option>

				<option value="file67">go-fiber-core/internal/services/serviceconfig/loader.go (0.0%)</option>

				<option value="file68">go-fiber-core/internal/services/user/user_service.go (77.8%)</option>

				<option value="file69">go-fiber-core/internal/utils/conver_json_number_to_int.go (0.0%)</option>

				<option value="file70">go-fiber-core/internal/utils/convert_map_to_dto.go (0.0%)</option>

				<option value="file71">go-fiber-core/internal/utils/env.go (0.0%)</option>

				<option value="file72">go-fiber-core/internal/utils/match_structs.go (0.0%)</option>

				<option value="file73">go-fiber-core/internal/utils/password.go (0.0%)</option>

				<option value="file74">go-fiber-core/internal/utils/random_id.go (0.0%)</option>

				<option value="file75">go-fiber-core/internal/utils/validator.go (0.0%)</option>

				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>

				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>

			</div>
		</div>
		<div id="content">

		<pre class="file" id="file0" style="display: none">// Package main implements the entry point for the API server.
package main

import (
        "context"
        "errors"
        "flag"
        "log"
        "net/http"
        "os/signal"
        "syscall"
        "time"

        "go-fiber-core/internal/appconfig"
        "go-fiber-core/internal/database/connections/gorm"
        "go-fiber-core/internal/database/connections/pgx"
        "go-fiber-core/internal/database/connections/redis"
        "go-fiber-core/internal/dtos/connect"
        "go-fiber-core/internal/server"

        "github.com/jackc/pgx/v5/pgxpool"
        _ "github.com/joho/godotenv/autoload"
        redisClient "github.com/redis/go-redis/v9"
)

// CAMBIO: gracefulShutdown ahora acepta los dos pools de PGX para cerrarlos.
func gracefulShutdown(
        fiberServer *server.FiberServer,
        done chan bool,
        gormService *gorm.GormConnectService,
        pgxWritePool *pgxpool.Pool,
        pgxReadPool *pgxpool.Pool,
        redisClient *redisClient.Client,
) <span class="cov0" title="0">{
        ctx, stop := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)
        defer stop()

        &lt;-ctx.Done()

        log.Println("‚¨áÔ∏è Shutting down gracefully, press Ctrl+C again to force")

        // 1. Apaga el servidor HTTP.
        shutdownCtx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()
        if err := fiberServer.ShutdownWithContext(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                if !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                        log.Printf("‚ùå Server forced to shutdown with error: %v", err)
                }</span>
        }
        <span class="cov0" title="0">log.Println("‚úÖ HTTP server stopped.")

        // 2. Cierra las dem√°s conexiones.
        log.Println("‚è≥ Closing database and Redis connections...")
        if err := gormService.Close(); err != nil </span><span class="cov0" title="0">{
                log.Printf("‚ùå Error closing GORM connections: %v", err)
        }</span>
        <span class="cov0" title="0">log.Println("‚úÖ GORM connections closed.")

        // CAMBIO: Cierra ambos pools de PGX.
        pgxWritePool.Close()
        log.Println("‚úÖ PGX write connection pool closed.")
        pgxReadPool.Close()
        log.Println("‚úÖ PGX read connection pool closed.")

        if err := redisClient.Close(); err != nil </span><span class="cov0" title="0">{
                log.Printf("‚ùå Error closing Redis connection: %v", err)
        }</span>
        <span class="cov0" title="0">log.Println("‚úÖ Redis connection closed.")

        done &lt;- true</span>
}

func main() <span class="cov0" title="0">{
        // Carga de configuraci√≥n desde el flag -config
        configPath := flag.String("config", "internal/appconfig/config.yml", "Ruta al archivo de configuraci√≥n YAML")
        flag.Parse()
        appConfig := appconfig.NewAppConfig(*configPath)

        // --- INICIALIZACI√ìN DE DEPENDENCIAS ---

        // 1. Conexi√≥n con GORM (Crea ambas conexiones, write y read)
        gormService, err := gorm.NewGormConnectService(appConfig.MultiDatabaseConfig)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("üíÄ Failed to connect to database with GORM: %v", err)
        }</span>

        // 2. Conexi√≥n con PGX (Crea los pools de write y read por separado)
        <span class="cov0" title="0">pgxWritePool, err := pgx.NewPgxConnection(appConfig.MultiDatabaseConfig.Pgx.Write)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("üíÄ Failed to connect to write database with PGX: %v", err)
        }</span>
        <span class="cov0" title="0">pgxReadPool, err := pgx.NewPgxConnection(appConfig.MultiDatabaseConfig.Pgx.Read)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("üíÄ Failed to connect to read database with PGX: %v", err)
        }</span>

        // 3. Conexi√≥n con Redis
        <span class="cov0" title="0">redisClient, err := redis.NewRedisClient(appConfig.Redis)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("üíÄ Failed to connect to Redis: %v", err)
        }</span>

        <span class="cov0" title="0">log.Println("üöÄ All connections established successfully!")

        // CAMBIO: Creaci√≥n del DTO con las 4 conexiones de base de datos + Redis.
        connect := connect.ConnectDTO{
                ConnectGormWrite: gormService.GetWriteDB(),
                ConnectGormRead:  gormService.GetReadDB(),
                ConnectPgxWrite:  pgxWritePool,
                ConnectPgxRead:   pgxReadPool,
                ConnectRedis:     redisClient,
        }

        // Creaci√≥n e inicializaci√≥n del servidor
        server := server.New(*appConfig, connect)
        server.RegisterRoutes()

        // --- ARRANQUE Y CIERRE ORDENADO ---
        done := make(chan bool, 1)

        go func() </span><span class="cov0" title="0">{
                log.Printf("üöÄ Starting server on port :9009")
                if err := server.Listen(":9009"); err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                        log.Printf("‚ùå HTTP server error: %s", err)
                }</span>
        }()

        // CAMBIO: Pasamos los dos pools de PGX al gestor de cierre.
        <span class="cov0" title="0">go gracefulShutdown(server, done, gormService, pgxWritePool, pgxReadPool, redisClient)

        &lt;-done
        log.Println("üëã Graceful shutdown complete. Exiting.")</span>
}
</pre>

		<pre class="file" id="file1" style="display: none">package cmd

import (
        "fmt"
        "go-fiber-core/internal/appconfig"
        "go-fiber-core/internal/database/connections/gorm"
        "go-fiber-core/internal/dtos/connect"
        "go-fiber-core/internal/models"
        userRepo "go-fiber-core/internal/repositories/user"
        userService "go-fiber-core/internal/services/user"
        "log"

        "github.com/spf13/cobra"
)

var createUserCmd = &amp;cobra.Command{
        Use:   "createUser",
        Short: "Crea un usuario de prueba en la base de datos.",
        Long: `Este comando inicializa la configuraci√≥n de la aplicaci√≥n y la conexi√≥n a la base de datos
para crear un usuario por defecto con los siguientes datos:
- Nombre:   test
- Email:    test@test.com
- Password: 123456

Es √∫til para entornos de desarrollo y pruebas.`,
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                fmt.Println("‚ñ∂Ô∏è  Iniciando la creaci√≥n del usuario de prueba...")

                // --- 1. Load Configuration ---
                configPath := "internal/appconfig/config.yml"
                appConfig := appconfig.NewAppConfig(configPath)
                fmt.Println("‚öôÔ∏è  Configuraci√≥n cargada.")

                // --- 2. Connect to the Database ---
                // Se crea el servicio que maneja ambas conexiones (lectura y escritura).
                gormService, err := gorm.NewGormConnectService(appConfig.MultiDatabaseConfig)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("‚ùå error conectando con GORM: %w", err)
                }</span>
                // Nos aseguramos de cerrar el servicio completo al final.
                <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                        if err := gormService.Close(); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Error cerrando la conexi√≥n de GORM: %v", err)
                        }</span>
                }()
                <span class="cov0" title="0">fmt.Println("‚úÖ Conectado a la base de datos exitosamente.")

                // --- 3. Dependency Injection (Enfocada en la Escritura) ---

                // El repositorio de usuario no cambia.
                userCrudRepo := userRepo.NewUserRepository()

                // CAMBIO: Creamos el DTO y poblamos SOLAMENTE la conexi√≥n de escritura,
                // ya que es la √∫nica que este comando necesita.
                connectDTO := connect.ConnectDTO{
                        ConnectGormWrite: gormService.GetWriteDB(),
                }

                // Creamos el servicio de escritura, que internamente usar√° la conexi√≥n del DTO.
                userCreatorService := userService.NewUserWriterService(userCrudRepo, connectDTO)
                fmt.Println("üîß Servicio de creaci√≥n de usuario inicializado.")

                // --- 4. Define and Create the User ---
                user := &amp;models.User{
                        Name:     "test",
                        Email:    "test@test.com",
                        Password: "123456",
                }

                fmt.Printf("üë§ Creando usuario con email: %s...\n", user.Email)
                err = userCreatorService.Create(cmd.Context(), user)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("‚ùå No se pudo crear el usuario: %w", err)
                }</span>

                <span class="cov0" title="0">fmt.Println("üéâ ¬°Usuario 'test' creado exitosamente!")
                return nil</span>
        },
}

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(createUserCmd)
}</span>
</pre>

		<pre class="file" id="file2" style="display: none">package cmd

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "go-fiber-core/internal/appconfig"
        "go-fiber-core/internal/database/connections/redis"
        "go-fiber-core/internal/jobqueue"
        "log/slog"
        "os"
        "strconv"

        redisClient "github.com/redis/go-redis/v9"

        "github.com/spf13/cobra"
)

// jobproducerCmd representa el comando jobproducer
var jobproducerCmd = &amp;cobra.Command{
        Use:   "jobproducer [total_jobs]",
        Short: "Encola un n√∫mero espec√≠fico de trabajos de prueba en Redis.",
        Long: `Este comando genera y encola trabajos simulados en una cola de Redis.
Es √∫til para probar y demostrar el sistema de workers distribuidos.

Argumentos:
  total_jobs    El n√∫mero de trabajos a generar y encolar.

Ejemplo:
  go run main.go jobproducer 100 --config path/to/your/config.yml`,
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))

                totalJobs, err := strconv.Atoi(args[0])
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("el argumento [total_jobs] no es un n√∫mero v√°lido: %w", err)
                }</span>
                <span class="cov0" title="0">if totalJobs &lt;= 0 </span><span class="cov0" title="0">{
                        return errors.New("el n√∫mero de trabajos debe ser un entero positivo")
                }</span>

                <span class="cov0" title="0">logger.Info("‚ñ∂Ô∏è Iniciando el productor de trabajos", "total_jobs", totalJobs)

                configPath, _ := cmd.Flags().GetString("config")
                logger.Debug("Cargando configuraci√≥n", "path", configPath)
                appConfig := appconfig.NewAppConfig(configPath)

                redisClient, err := redis.NewRedisClient(appConfig.Redis)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("‚ùå no se pudo conectar con Redis: %w", err)
                }</span>
                // --- INICIO DE LA CORRECCI√ìN ---
                // Verificamos el error al cerrar la conexi√≥n de Redis.
                <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                        if err := redisClient.Close(); err != nil </span><span class="cov0" title="0">{
                                logger.Error("Error closing Redis client", "error", err)
                        }</span>
                }()
                // --- FIN DE LA CORRECCI√ìN ---
                <span class="cov0" title="0">logger.Info("‚úÖ Conectado a Redis exitosamente.")

                err = enqueueJobs(cmd.Context(), redisClient, logger, totalJobs)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">logger.Info("üéâ Proceso de encolado finalizado exitosamente.", "total_jobs_enqueued", totalJobs)
                return nil</span>
        },
        Args: cobra.ExactArgs(1),
}

// enqueueJobs contiene la l√≥gica de negocio para crear y encolar los trabajos.
func enqueueJobs(ctx context.Context, redisClient *redisClient.Client, logger *slog.Logger, totalJobs int) error <span class="cov0" title="0">{
        logger.Info("üì¨ Encolando trabajos...")

        for i := 1; i &lt;= totalJobs; i++ </span><span class="cov0" title="0">{
                data := map[string]any{
                        "to":      fmt.Sprintf("user%d@example.com", i),
                        "subject": fmt.Sprintf("Notificaci√≥n #%d", i),
                        "body":    fmt.Sprintf("Hola User %d, este es un mensaje automatizado.", i),
                }

                rawData, err := json.Marshal(data)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error serializando los datos del trabajo", "job_id", i, "error", err)
                        continue</span>
                }

                <span class="cov0" title="0">job := jobqueue.JobMessage{
                        Type: "send_email",
                        Data: rawData,
                }

                payload, err := json.Marshal(job)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error serializando el mensaje del job", "job_id", i, "error", err)
                        continue</span>
                }

                <span class="cov0" title="0">if err := redisClient.LPush(ctx, "job_queue", payload).Err(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error enviando el trabajo a Redis", "job_id", i, "error", err)
                }</span> else<span class="cov0" title="0"> {
                        logger.Debug("‚úâÔ∏è Trabajo encolado correctamente", "job_id", i)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(jobproducerCmd)
        jobproducerCmd.Flags().String("config", "internal/appconfig/config.yml", "Ruta al archivo de configuraci√≥n YAML")
}</span>
</pre>

		<pre class="file" id="file3" style="display: none">package cmd

import (
        "errors"
        "fmt"
        "go-fiber-core/internal/appconfig"
        "go-fiber-core/internal/database/migrations"
        "go-fiber-core/internal/dtos/config"
        "go-fiber-core/internal/utils"
        "log"

        "github.com/spf13/cobra"
)

// Usamos variables no exportadas a nivel de paquete para compartir el estado
// entre las funciones PreRun y Run de los comandos.
var (
        // cfgPath se llenar√° con el valor del flag global --config.
        cfgPath string

        // step se llenar√° con el valor del flag local --step del comando 'down'.
        step int

        // Instancias compartidas por los subcomandos, inicializadas en PersistentPreRunE.
        migrationService *migrations.MigrationService
        appCfg           *config.AppConfig
        cleanupFunc      func()
)

// migrationCmd es el comando padre para todas las operaciones de migraci√≥n.
var migrationsCmd = &amp;cobra.Command{
        Use:   "migrations",
        Short: "Ejecuta los comandos de migraci√≥n de la base de datos",

        // PersistentPreRunE se ejecuta ANTES de cualquier subcomando de 'migrations'.
        // Es el lugar perfecto para la l√≥gica de inicializaci√≥n compartida.
        PersistentPreRunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                // 1. Cargar configuraci√≥n.
                loadedCfg := appconfig.NewAppConfig(cfgPath)
                appCfg = loadedCfg // Guardamos la config para usarla en los subcomandos.

                // 2. Crear el servicio de migraci√≥n.
                service, cleanup, err := migrations.NewMigrationService(appCfg.MultiDatabaseConfig)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error creando MigrationService: %w", err)
                }</span>
                <span class="cov0" title="0">migrationService = service // Guardamos el servicio.
                cleanupFunc = cleanup      // Guardamos la funci√≥n de limpieza.

                return nil</span>
        },

        // PersistentPostRun se ejecuta DESPU√âS de cualquier subcomando.
        // Ideal para tareas de limpieza.
        PersistentPostRun: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                if cleanupFunc != nil </span><span class="cov0" title="0">{
                        cleanupFunc()
                }</span>
        },
}

var upCmd = &amp;cobra.Command{
        Use:   "up",
        Short: "Aplica todas las migraciones disponibles",
        // Usamos RunE para poder devolver errores de forma idiom√°tica.
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                log.Println("Aplicando migraciones...")
                return migrationService.Up()
        }</span>,
}

var downCmd = &amp;cobra.Command{
        Use:   "down",
        Short: "Revierte la √∫ltima migraci√≥n (o m√∫ltiples con --step)",
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                if utils.IsProduction(*appCfg) </span><span class="cov0" title="0">{
                        return errors.New("no se permite ejecutar rollback en producci√≥n")
                }</span>
                <span class="cov0" title="0">log.Printf("Revirtiendo %d migraci√≥n(es)...\n", step)
                return migrationService.Down(step)</span>
        },
}

var createCmd = &amp;cobra.Command{
        Use:   "create [name]",
        Short: "Crea un nuevo archivo de migraci√≥n SQL",
        Args:  cobra.ExactArgs(1), // Requiere exactamente un argumento: el nombre.
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                name := args[0]
                log.Printf("Creando archivo de migraci√≥n: %s...\n", name)
                return migrationService.Create(name)
        }</span>,
}

var statusCmd = &amp;cobra.Command{
        Use:   "status",
        Short: "Muestra la versi√≥n y el estado de las migraciones",
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                version, err := migrationService.CurrentVersion()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">fmt.Printf("Versi√≥n actual de la migraci√≥n: %d\n\n", version)
                return migrationService.PrintStatus()</span>
        },
}

// init registra los comandos y sus flags en Cobra.
func init() <span class="cov0" title="0">{
        // Flags persistentes est√°n disponibles para el comando y todos sus hijos.
        // Definimos --config en el rootCmd para que sea global para toda la aplicaci√≥n.
        rootCmd.PersistentFlags().StringVar(&amp;cfgPath, "config", "internal/appconfig/config.yml", "Ruta al archivo de configuraci√≥n YAML")

        // Flags locales solo est√°n disponibles para el comando espec√≠fico donde se definen.
        downCmd.Flags().IntVar(&amp;step, "step", 1, "N√∫mero de migraciones a revertir (por defecto 1)")

        // Agregamos los subcomandos al comando padre 'migrations'.
        migrationsCmd.AddCommand(upCmd)
        migrationsCmd.AddCommand(downCmd)
        migrationsCmd.AddCommand(createCmd)
        migrationsCmd.AddCommand(statusCmd)

        // Finalmente, agregamos el comando 'migrations' al comando ra√≠z.
        rootCmd.AddCommand(migrationsCmd)
}</span>
</pre>

		<pre class="file" id="file4" style="display: none">package cmd

import (
        "errors"
        "fmt"
        "log/slog"
        "os"
        "time"

        resty "github.com/go-resty/resty/v2" // ‚úÖ ASEG√öRATE DE QUE ESTA L√çNEA EST√â PRESENTE
        "github.com/spf13/cobra"

        "go-fiber-core/internal/adapters"
        "go-fiber-core/internal/appconfig"
        "go-fiber-core/internal/dtos"
)

// getreversaladapterCmd obtiene datos de reversiones desde el backoffice.
var getreversaladapterCmd = &amp;cobra.Command{
        Use:   "getreversaladapter --customer-id [ID] --start-date [YYYY-MM-DD]",
        Short: "Ejecuta una consulta de reversiones al adaptador del backoffice.",
        Long: `Este comando construye una petici√≥n para obtener datos de reversiones
y la env√≠a a trav√©s del adaptador del backoffice. Es una herramienta de
desarrollo y depuraci√≥n para probar la integraci√≥n.

Ejemplo:
go run main.go getreversaladapter --customer-id 564526 --start-date 2024-02-21`,
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                // --- 1. Inicializaci√≥n (Logger y Configuraci√≥n) ---
                logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))
                logger.Info("‚ñ∂Ô∏è Ejecutando comando getreversaladapter")

                configPath, _ := cmd.Flags().GetString("config")
                appConfig := appconfig.NewAppConfig(configPath)

                // --- 2. Lectura y Validaci√≥n de Flags ---
                customerID, _ := cmd.Flags().GetInt("customer-id")
                dateStr, _ := cmd.Flags().GetString("start-date")

                if customerID == 0 </span><span class="cov0" title="0">{
                        return errors.New("el flag --customer-id es obligatorio y no puede ser 0")
                }</span>

                <span class="cov0" title="0">startDate, err := time.Parse("2006-01-02", dateStr)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("formato de fecha inv√°lido para --start-date: %w", err)
                }</span>

                // --- 3. Creaci√≥n de Dependencias (Inyecci√≥n de Dependencias) ---
                // El comando crea el cliente HTTP y se lo pasa al adaptador.
                <span class="cov0" title="0">httpClient := resty.New().
                        SetTimeout(10 * time.Second).
                        SetBaseURL(appConfig.ApiBackoffice.Url)

                // El adaptador ahora recibe sus dependencias, no las crea √©l mismo.
                adapter := adapters.NewBackofficeAdapter(httpClient)

                // --- 4. Ejecuci√≥n de la L√≥gica de Negocio ---
                reversalRequest := dtos.Config{
                        Config: dtos.BackofficeReversal{
                                CustomerID:       customerID,
                                InstallmentState: []int{39, 40, 41, 42}, // Se puede mover a flags si es necesario
                                Extra:            dtos.BackofficeReversalExtra{StartProduct: startDate},
                                Imputation:       true,
                        },
                }

                logger.Info("Enviando petici√≥n de reversi√≥n...", "customer_id", customerID, "start_date", dateStr)

                // Pasamos el contexto del comando a la llamada del adaptador.
                // Esto permite cancelar la petici√≥n si el comando se interrumpe (ej. Ctrl+C).
                resp, err := adapter.PostReversal(cmd.Context(), reversalRequest)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error al llamar al adaptador de backoffice", "error", err)
                        return fmt.Errorf("la petici√≥n de reversi√≥n fall√≥: %w", err)
                }</span>

                <span class="cov0" title="0">logger.Info("‚úÖ Petici√≥n exitosa", "status_code", resp.StatusCode())
                // Usamos slog para imprimir la respuesta de forma estructurada.
                logger.Info("Respuesta recibida", "body", string(resp.Body()))

                return nil</span>
        },
}

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(getreversaladapterCmd)

        // Se definen flags para que el comando sea reutilizable y no tenga datos hardcodeados.
        getreversaladapterCmd.Flags().Int("customer-id", 0, "ID del cliente para la consulta")
        getreversaladapterCmd.Flags().String("start-date", "", "Fecha de inicio del producto (formato: YYYY-MM-DD)")

        // Hacemos que los flags sean obligatorios para evitar errores.
        _ = getreversaladapterCmd.MarkFlagRequired("customer-id")
        _ = getreversaladapterCmd.MarkFlagRequired("start-date")
}</span>
</pre>

		<pre class="file" id="file5" style="display: none">package cmd

import (
        "os"

        "github.com/spf13/cobra"
)

// rootCmd represents the base command when called without any subcommands
var rootCmd = &amp;cobra.Command{
        Use:   "go-fiber-core",
        Short: "A brief description of your application",
        Long: `Esto es el root A longer description that spans multiple lines and likely contains
examples and usage of using your application. For example:

Cobra is a CLI library for Go that empowers applications.
This application is a tool to generate the needed files
to quickly create a Cobra application.`,
        // Uncomment the following line if your bare application
        // has an action associated with it:
        // Run: func(cmd *cobra.Command, args []string) { },
}

// Execute adds all child commands to the root command and sets flags appropriately.
// This is called by main.main(). It only needs to happen once to the rootCmd.
func Execute() <span class="cov0" title="0">{
        err := rootCmd.Execute()
        if err != nil </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>
}

func init() <span class="cov0" title="0">{
        // Here you will define your flags and configuration settings.
        // Cobra supports persistent flags, which, if defined here,
        // will be global for your application.

        // rootCmd.PersistentFlags().StringVar(&amp;cfgFile, "config", "", "config file (default is $HOME/.go-fiber-core.yaml)")

        // Cobra also supports local flags, which will only run
        // when this action is called directly.
        rootCmd.Flags().BoolP("toggle", "t", false, "Help message for toggle")
}</span>
</pre>

		<pre class="file" id="file6" style="display: none">package cmd

import (
        "fmt"
        "go-fiber-core/internal/database/seeders"
        "log"

        // Aseg√∫rate de importar el paquete correcto donde tienes tu l√≥gica de seeders
        "github.com/spf13/cobra"
)

// Crear un nuevo comando de tipo Cobra
var seedCmd = &amp;cobra.Command{
        Use:   "seed",
        Short: "Ejecuta los seeders para poblar la base de datos",
        RunE: func(_ *cobra.Command, _ []string) error <span class="cov0" title="0">{
                // Llamar a la funci√≥n SeedDatabase que ejecuta los seeders
                fmt.Println("Ejecutando los seeders...")

                if err := seeders.SeedDatabase(); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Error al ejecutar los seeders: %v", err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        },
}

func init() <span class="cov0" title="0">{
        // Registrar el comando `seed` para que pueda ejecutarse en la CLI
        rootCmd.AddCommand(seedCmd)
}</span>
</pre>

		<pre class="file" id="file7" style="display: none">package cmd

import (
        "fmt"

        "github.com/spf13/cobra"
)

// sendemailCmd represents the sendemail command
var sendemailCmd = &amp;cobra.Command{
        Use:   "sendemail",
        Short: "A brief description of your command",
        Long: `A longer description that spans multiple lines and likely contains examples
and usage of using your command. For example:

Cobra is a CLI library for Go that empowers applications.
This application is a tool to generate the needed files
to quickly create a Cobra application.`,
        Run: func(_ *cobra.Command, _ []string) <span class="cov0" title="0">{
                fmt.Println("sendemail called desde el comando de cobra desde consola directamente")
                // dataEmailContacto := typesemail.DataEmailContacto{
                //         Destination: "depabloshector@gmail.com",
                //         Subject:     "Notificaciones",
                // }

                // data := make(map[string]any)

                // // Cambiar
                // data["name"] = "H√©ctor Depablos T."
                // data["edad"] = 45

                // sendEmail := typesemail.NewEmailService(dataEmailContacto)
                // sendEmail.SendEmailContacto(data)

                fmt.Println("Fin del comando")
        }</span>,
}

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(sendemailCmd)

        // Here you will define your flags and configuration settings.

        // Cobra supports Persistent Flags which will work for this command
        // and all subcommands, e.g.:
        // sendemailCmd.PersistentFlags().String("foo", "", "A help for foo")

        // Cobra supports local flags which will only run when this command
        // is called directly, e.g.:
        // sendemailCmd.Flags().BoolP("toggle", "t", false, "Help message for toggle")
}</span>
</pre>

		<pre class="file" id="file8" style="display: none">package cmd

import (
        "encoding/json"
        "fmt"
        "go-fiber-core/internal/services/serviceconfig"

        "github.com/spf13/cobra"
)

// serviceconfigallCmd represents the serviceconfigall command
var serviceconfigallCmd = &amp;cobra.Command{
        Use:   "serviceconfigall",
        Short: "A brief description of your command",
        Long: `A longer description that spans multiple lines and likely contains examples
and usage of using your command. For example:

Cobra is a CLI library for Go that empowers applications.
This application is a tool to generate the needed files
to quickly create a Cobra application.`,
        Run: func(_ *cobra.Command, _ []string) <span class="cov0" title="0">{
                params := map[string]any{
                        "age":    45,
                        "salary": 100000,
                }

                services := []serviceconfig.ServiceRegistryRow{
                        {Path: "loanrisk/NewAgeService", Order: 1},
                        {Path: "loanrisk/NewSalaryService", Order: 2},
                        {Path: "loanrisk/NewIsRenovationService", Order: 3},
                        {Path: "loanrisk/NewRiskLevelService", Order: 4},
                }

                result, err := serviceconfig.ExecuteServicesInOrder(services, params)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("üö® Error:", err)
                        return
                }</span>

                // Mostrar JSON final
                <span class="cov0" title="0">jsonBytes, _ := json.MarshalIndent(result, "", "  ")
                fmt.Println("‚úÖ Resultado Final:")
                fmt.Println(string(jsonBytes))</span>
        },
}

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(serviceconfigallCmd)
}</span>
</pre>

		<pre class="file" id="file9" style="display: none">package cmd

import (
        "encoding/json"
        "fmt"
        "go-fiber-core/internal/services/serviceconfig"

        "github.com/spf13/cobra"
)

// serviceconfigonlyCmd represents the serviceconfigonly command
var serviceconfigonlyCmd = &amp;cobra.Command{
        Use:   "serviceconfigonly",
        Short: "A brief description of your command",
        Long: `A longer description that spans multiple lines and likely contains examples
and usage of using your command. For example:

Cobra is a CLI library for Go that empowers applications.
This application is a tool to generate the needed files
to quickly create a Cobra application.`,
        Run: func(_ *cobra.Command, _ []string) <span class="cov0" title="0">{

                params := map[string]any{
                        "age":    45,
                        "salary": 100000,
                }

                pathService := "loanrisk/NewIsRenovationService"
                err := serviceconfig.ExecuteService(pathService, &amp;params)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("Error al ejecutar el servicio:", err)
                        return
                }</span>

                // Mostrar JSON final
                <span class="cov0" title="0">jsonBytes, _ := json.MarshalIndent(params, "", "  ")
                fmt.Println("‚úÖ Resultado Final:")
                fmt.Println(string(jsonBytes))</span>
        },
}

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(serviceconfigonlyCmd)

        // Here you will define your flags and configuration settings.

        // Cobra supports Persistent Flags which will work for this command
        // and all subcommands, e.g.:
        // serviceconfigonlyCmd.PersistentFlags().String("foo", "", "A help for foo")

        // Cobra supports local flags which will only run when this command
        // is called directly, e.g.:
        // serviceconfigonlyCmd.Flags().BoolP("toggle", "t", false, "Help message for toggle")
}</span>
</pre>

		<pre class="file" id="file10" style="display: none">/*
Copyright ¬© 2025 NAME HERE &lt;EMAIL ADDRESS&gt;
*/
package main

import "go-fiber-core/cmd/cmd-cli/cmd"

func main() <span class="cov0" title="0">{
        cmd.Execute()
}</span>
</pre>

		<pre class="file" id="file11" style="display: none">package main

import (
        "context"
        "flag"
        "go-fiber-core/internal/appconfig"
        "go-fiber-core/internal/database/connections/redis"
        "go-fiber-core/internal/jobqueue"
        "log"
        "os"
        "os/signal"
        "syscall"
)

func main() <span class="cov0" title="0">{
        configPath := flag.String("config", "internal/appconfig/config.yml", "Ruta al archivo de configuraci√≥n YAML")
        flag.Parse()
        appConfig := appconfig.NewAppConfig(*configPath)

        redisClient, err := redis.NewRedisClient(appConfig.Redis)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("‚ùå Worker no pudo conectar con Redis: %v", err)
        }</span>

        // --- INICIO DE LA CORRECCI√ìN ---
        // Verificamos el error al cerrar la conexi√≥n de Redis.
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := redisClient.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error closing Redis client: %v", err)
                }</span>
        }()
        // --- FIN DE LA CORRECCI√ìN ---
        <span class="cov0" title="0">log.Println("‚úÖ Worker conectado a Redis.")

        // Contexto para un cierre ordenado (graceful shutdown).
        ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)
        defer stop()

        // Registrar los manejadores de trabajos (handlers).
        jobqueue.RegisterHandler("send_email", handleSendEmail)
        jobqueue.RegisterHandler("generate_report", handleGenerateReport)

        // Iniciar el worker. Este se ejecutar√° hasta que el contexto sea cancelado.
        log.Println("‚ñ∂Ô∏è Iniciando worker... Presiona Ctrl+C para detener.")
        jobqueue.StartWorker(ctx, redisClient, "job_queue")

        log.Println("‚èπÔ∏è Worker detenido. Limpiando y saliendo.")</span>
}

// Handlers de ejemplo
func handleSendEmail(data []byte) error <span class="cov0" title="0">{
        log.Println("üìß Procesando trabajo 'send_email'...")
        log.Printf("   Datos: %s", string(data))
        return nil
}</span>

func handleGenerateReport(data []byte) error <span class="cov0" title="0">{
        log.Println("üìä Procesando trabajo 'generate_report'...")
        log.Printf("   Datos: %s", string(data))
        return nil
}</span>
</pre>

		<pre class="file" id="file12" style="display: none">package adapters

import (
        "context"

        resty "github.com/go-resty/resty/v2" // ‚úÖ Esta l√≠nea soluciona el error

        "go-fiber-core/internal/dtos"
)

// BackofficeAdapter es una mejor denominaci√≥n, ya que su funci√≥n es adaptar.
type BackofficeAdapter struct {
        client *resty.Client
}

// Constructor: Ahora recibe sus dependencias (el cliente HTTP).
// No lee archivos ni flags. Es una funci√≥n pura y simple.
func NewBackofficeAdapter(client *resty.Client) *BackofficeAdapter <span class="cov8" title="1">{
        return &amp;BackofficeAdapter{
                client: client,
        }
}</span>

// PostReversal: Ahora recibe un context.Context como primer argumento.
// Esta es una pr√°ctica est√°ndar para operaciones que pueden ser canceladas
// o tener un timeout, como las llamadas de red.
func (a *BackofficeAdapter) PostReversal(ctx context.Context, backofficeReversal dtos.Config) (*resty.Response, error) <span class="cov8" title="1">{
        // La URL base ya est√° configurada en el cliente, solo a√±adimos el endpoint.
        const endpoint = "/collections/collect-data"

        // La llamada a Resty ahora incluye el contexto.
        resp, err := a.client.R().
                SetContext(ctx).
                SetBody(backofficeReversal).
                SetHeader("Content-Type", "application/json").
                Post(endpoint)

        // El adaptador ya no loguea. Su √∫nica responsabilidad es ejecutar
        // la petici√≥n y devolver el resultado o el error. Quien lo llama
        // (el comando) se encargar√° de loguear.
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return resp, nil</span>
}
</pre>

		<pre class="file" id="file13" style="display: none">package adapters

import (
        "context"
        "time"

        resty "github.com/go-resty/resty/v2"

        "go-fiber-core/internal/dtos"
        "go-fiber-core/internal/dtos/config"
)

type DiscordAdapter struct {
        client *resty.Client
        // CAMBIO: El tipo de la configuraci√≥n es 'ApiConfig', no 'ApiDiscord'.
        apiConfig config.ApiConfig
}

// NewDiscordAdapter recibe la configuraci√≥n gen√©rica 'ApiConfig'.
func NewDiscordAdapter(cfg config.ApiConfig) *DiscordAdapter <span class="cov0" title="0">{
        client := resty.New().
                SetTimeout(10*time.Second).
                SetHeader("Content-Type", "application/json")

        return &amp;DiscordAdapter{
                client:    client,
                apiConfig: cfg,
        }
}</span>

// El m√©todo Send no necesita cambios.
func (a *DiscordAdapter) Send(ctx context.Context, notification dtos.NotificationDiscord) (*resty.Response, error) <span class="cov0" title="0">{
        resp, err := a.client.R().
                SetContext(ctx).
                SetBody(notification).
                Post(a.apiConfig.Url)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return resp, nil</span>
}
</pre>

		<pre class="file" id="file14" style="display: none">package appconfig

import (
        "go-fiber-core/internal/dtos/config"
        "log"
        "reflect"

        "github.com/spf13/viper"
)

func load(v *viper.Viper, key string, target any) <span class="cov0" title="0">{
        if err := v.UnmarshalKey(key, target); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("error loading config for '%s': %v (type: %s)", key, err, reflect.TypeOf(target))
        }</span>
}

func LoadAppConfig(v *viper.Viper) *config.AppConfig <span class="cov0" title="0">{
        cfg := &amp;config.AppConfig{}

        load(v, "app", &amp;cfg.App)
        load(v, "jwt", &amp;cfg.JWTConfig)
        load(v, "database", &amp;cfg.MultiDatabaseConfig)
        load(v, "redis", &amp;cfg.Redis)
        load(v, "server", &amp;cfg.Server)
        load(v, "email_config", &amp;cfg.EmailConfig)
        load(v, "apis.backoffice", &amp;cfg.ApiBackoffice)
        load(v, "apis.discord", &amp;cfg.ApiDiscord)

        return cfg
}</span>
func NewAppConfig(configPath string) *config.AppConfig <span class="cov0" title="0">{
        v := New(configPath) // Le pasamos la ruta
        return LoadAppConfig(v)
}</span>
</pre>

		<pre class="file" id="file15" style="display: none">package appconfig

import (
        "log"
        "os" // üëà Aseg√∫rate de importar "os"
        "strings"
        "sync"

        "github.com/spf13/viper"
)

var (
        instance *viper.Viper
        once     sync.Once
)

// New ahora recibe la ruta del archivo de configuraci√≥n
func New(configPath string) *viper.Viper <span class="cov0" title="0">{
        once.Do(func() </span><span class="cov0" title="0">{
                v := viper.New()

                if configPath == "" </span><span class="cov0" title="0">{
                        log.Fatal("La ruta del archivo de configuraci√≥n no puede estar vac√≠a")
                }</span>
                <span class="cov0" title="0">v.SetConfigFile(configPath)

                if err := v.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Error al cargar el archivo de configuraci√≥n desde '%s': %v", configPath, err)
                }</span>

                // Habilitar la lectura de variables de entorno para que os.ExpandEnv las encuentre
                <span class="cov0" title="0">v.AutomaticEnv()
                v.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))

                // --- BUCLE RESTAURADO ---
                // Este bucle es NECESARIO porque tu config.yml usa placeholders ${...}.
                // Recorre todas las claves cargadas desde el YAML y sustituye los placeholders
                // con las variables de entorno correspondientes.
                for _, key := range v.AllKeys() </span><span class="cov0" title="0">{
                        value := v.GetString(key)
                        if strings.Contains(value, "${") </span><span class="cov0" title="0">{
                                // os.ExpandEnv reemplaza ${VAR} o $VAR con el valor de la variable de entorno.
                                v.Set(key, os.ExpandEnv(value))
                        }</span>
                }

                <span class="cov0" title="0">instance = v</span>
        })

        <span class="cov0" title="0">return instance</span>
}
</pre>

		<pre class="file" id="file16" style="display: none">package cronjobs

import (
        "fmt"
        "log"

        cron "github.com/robfig/cron/v3" // ‚úÖ Esta l√≠nea soluciona el error
)

// InitCronJobs inicializa y programa las tareas cron
func InitCronJobs() <span class="cov0" title="0">{
        // Crear una nueva instancia de cron
        c := cron.New()

        // Agregar una tarea que se ejecute todos los d√≠as a las 2:00 AM
        _, err := c.AddFunc("0 2 * * *", func() </span><span class="cov0" title="0">{
                log.Println("Ejecutando tarea programada: Limpieza de datos") // Descomentado para visibilidad
                performDataCleanup()
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error al agregar tarea cron: %v", err)
        }</span>

        // Agregar otra tarea que se ejecute cada 1 minuto
        <span class="cov0" title="0">_, err = c.AddFunc("@every 1m", func() </span><span class="cov0" title="0">{
                log.Println("Ejecutando tarea programada: Env√≠o de notificaciones cada minuto") // Descomentado para visibilidad
                performDataCleanup()
                sendNotifications()
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error al agregar tarea cron: %v", err)
        }</span>

        // Iniciar el cron
        <span class="cov0" title="0">c.Start()

        // Mantener el cron activo mientras la aplicaci√≥n est√© en ejecuci√≥n
        select </span>{}
}

// performDataCleanup es una funci√≥n de ejemplo para limpiar datos
func performDataCleanup() <span class="cov0" title="0">{
        // Aqu√≠ puedes implementar la l√≥gica para limpiar datos en PostgreSQL
        fmt.Println("Limpiando datos antiguos...")
        // Ejemplo: Eliminar registros antiguos de la base de datos
}</span>

// sendNotifications es una funci√≥n de ejemplo para enviar notificaciones
func sendNotifications() <span class="cov0" title="0">{
        // Aqu√≠ puedes implementar la l√≥gica para enviar notificaciones
        fmt.Println("Enviando notificaciones... cada 1 minuto")
        // Ejecutar todos los servicios en el orden especificado en la base de datos
        // err := services.ExecuteAllServices()
        // if err != nil {
        //         log.Fatalf("Error ejecutando los servicios, desde el cron: %v", err)
        // }

        fmt.Println("Todos los servicios fueron ejecutados exitosamente, desde el cron")
}</span>
</pre>

		<pre class="file" id="file17" style="display: none">package gorm

import (
        "database/sql"
        "fmt"
        "log"
        "strings"
        "time"

        "go-fiber-core/internal/dtos/config"

        "gorm.io/driver/mysql"
        "gorm.io/driver/postgres"
        "gorm.io/gorm"
)

// GormConnectService ahora contiene las conexiones de lectura y escritura.
type GormConnectService struct {
        dbWrite    *gorm.DB
        sqlDBWrite *sql.DB
        dbRead     *gorm.DB
        sqlDBRead  *sql.DB
}

// createGormConnection es un helper interno para no duplicar la l√≥gica de conexi√≥n.
func createGormConnection(cfg config.GormConnectionConfig) (*gorm.DB, *sql.DB, error) <span class="cov0" title="0">{
        var dialector gorm.Dialector
        switch strings.ToLower(cfg.Driver) </span>{
        case "postgres":<span class="cov0" title="0">
                dsn := fmt.Sprintf("host=%s port=%d user=%s dbname=%s password=%s sslmode=disable search_path=%s",
                        cfg.Host, cfg.Port, cfg.Username, cfg.Database, cfg.Password, cfg.Schema)
                dialector = postgres.Open(dsn)</span>
        case "mysql":<span class="cov0" title="0">
                dsn := fmt.Sprintf("%s:%s@tcp(%s:%d)/%s?parseTime=true",
                        cfg.Username, cfg.Password, cfg.Host, cfg.Port, cfg.Database)
                dialector = mysql.Open(dsn)</span>
        default:<span class="cov0" title="0">
                return nil, nil, fmt.Errorf("driver GORM no soportado: %s", cfg.Driver)</span>
        }

        <span class="cov0" title="0">db, err := gorm.Open(dialector, &amp;gorm.Config{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("fall√≥ al abrir la conexi√≥n GORM hacia %s: %w", cfg.Host, err)
        }</span>

        <span class="cov0" title="0">sqlDB, err := db.DB()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("fall√≥ al obtener la instancia DB de GORM para %s: %w", cfg.Host, err)
        }</span>

        <span class="cov0" title="0">if err := sqlDB.Ping(); err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("fall√≥ el ping a la base de datos GORM en %s: %w", cfg.Host, err)
        }</span>

        <span class="cov0" title="0">sqlDB.SetMaxOpenConns(cfg.MaxOpenConns)
        sqlDB.SetMaxIdleConns(cfg.MaxIdleConns)
        sqlDB.SetConnMaxLifetime(time.Duration(cfg.MaxConnLifeTimeInSeconds) * time.Second)

        log.Printf("‚úÖ Conexi√≥n GORM exitosa a %s", cfg.Host)
        return db, sqlDB, nil</span>
}

// NewGormConnectService ahora crea las dos conexiones (escritura y lectura).
func NewGormConnectService(cfg config.MultiDatabaseConfig) (*GormConnectService, error) <span class="cov0" title="0">{
        dbWrite, sqlDBWrite, err := createGormConnection(cfg.Gorm.Write)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">dbRead, sqlDBRead, err := createGormConnection(cfg.Gorm.Read)
        if err != nil </span><span class="cov0" title="0">{
                // Si la conexi√≥n de lectura falla, cerramos la de escritura antes de salir.
                sqlDBWrite.Close()
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;GormConnectService{
                dbWrite:    dbWrite,
                sqlDBWrite: sqlDBWrite,
                dbRead:     dbRead,
                sqlDBRead:  sqlDBRead,
        }, nil</span>
}

// GetWriteDB devuelve la conexi√≥n de escritura.
func (s *GormConnectService) GetWriteDB() *gorm.DB <span class="cov0" title="0">{
        return s.dbWrite
}</span>

// GetReadDB devuelve la conexi√≥n de lectura.
func (s *GormConnectService) GetReadDB() *gorm.DB <span class="cov0" title="0">{
        return s.dbRead
}</span>

// Close ahora cierra ambas conexiones.
func (s *GormConnectService) Close() error <span class="cov0" title="0">{
        log.Println("üîå Desconectando de las bases de datos (GORM)...")
        errWrite := s.sqlDBWrite.Close()
        errRead := s.sqlDBRead.Close()

        if errWrite != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error cerrando la conexi√≥n de escritura: %w", errWrite)
        }</span>
        <span class="cov0" title="0">if errRead != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error cerrando la conexi√≥n de lectura: %w", errRead)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetWriteSQLDB devuelve el *sql.DB de escritura.
func (s *GormConnectService) GetWriteSQLDB() *sql.DB <span class="cov0" title="0">{
        return s.sqlDBWrite
}</span>

// GetReadSQLDB devuelve el *sql.DB de lectura.
func (s *GormConnectService) GetReadSQLDB() *sql.DB <span class="cov0" title="0">{
        return s.sqlDBRead
}</span>
</pre>

		<pre class="file" id="file18" style="display: none">package pgx

import (
        "context"
        "fmt"
        "log"
        "time"

        "github.com/jackc/pgx/v5/pgxpool"
        "go-fiber-core/internal/dtos/config"
)

// NewPgxConnection crea y devuelve un nuevo pool de conexiones pgx.
// Mantiene la funcionalidad original, pero ahora usa la config espec√≠fica.
func NewPgxConnection(cfg config.PgxConnectionConfig) (*pgxpool.Pool, error) <span class="cov0" title="0">{
        dsn := fmt.Sprintf("postgresql://%s:%s@%s:%d/%s",
                cfg.Username, cfg.Password, cfg.Host, cfg.Port, cfg.Database)

        config, err := pgxpool.ParseConfig(dsn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no se pudo parsear la configuraci√≥n de la base de datos para pgx: %w", err)
        }</span>

        <span class="cov0" title="0">config.MaxConns = int32(cfg.MaxConns)
        // Puedes a√±adir m√°s configuraciones del pool aqu√≠ si las necesitas
        config.MaxConnLifetime = 1 * time.Hour
        config.MaxConnIdleTime = 30 * time.Minute

        pool, err := pgxpool.NewWithConfig(context.Background(), config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no se pudo crear el pool de conexiones pgx: %w", err)
        }</span>

        // Verificar la conexi√≥n antes de devolver el pool
        <span class="cov0" title="0">if err := pool.Ping(context.Background()); err != nil </span><span class="cov0" title="0">{
                pool.Close() // Aseg√∫rate de cerrar el pool si el ping falla
                return nil, fmt.Errorf("no se pudo hacer ping a la base de datos pgx en %s: %w", cfg.Host, err)
        }</span>

        <span class="cov0" title="0">log.Printf("‚úÖ Conexi√≥n PGX exitosa a %s", cfg.Host)

        return pool, nil</span>
}
</pre>

		<pre class="file" id="file19" style="display: none">package redis

import (
        "context"
        "fmt"
        "log"
        "time"

        redis "github.com/redis/go-redis/v9" // ‚úÖ Esta l√≠nea soluciona el error

        "go-fiber-core/internal/dtos/config"
)

// NewRedisClient crea y devuelve un nuevo cliente de Redis.
// Devuelve un error expl√≠cito en caso de fallo.
func NewRedisClient(redisConfig config.Redis) (*redis.Client, error) <span class="cov0" title="0">{
        rdb := redis.NewClient(&amp;redis.Options{
                Addr:     fmt.Sprintf("%s:%s", redisConfig.RedisHost, redisConfig.RedisPort),
                Password: redisConfig.RedisPassword,
                DB:       redisConfig.RedisDatabase,
                PoolSize: redisConfig.RedisPoolSize,
        })

        // Usar un contexto con timeout para la verificaci√≥n inicial
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        // Ping para confirmar que la conexi√≥n es exitosa
        if err := rdb.Ping(ctx).Err(); err != nil </span><span class="cov0" title="0">{
                // Intenta cerrar el cliente si el ping falla para liberar recursos
                if closeErr := rdb.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        log.Printf("Error closing Redis client after a failed ping: %v", closeErr)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("error connecting to Redis: %w", err)</span>
        }

        <span class="cov0" title="0">log.Println("‚úÖ Redis connection successful.")

        return rdb, nil</span>
}
</pre>

		<pre class="file" id="file20" style="display: none">package database

import "sort"

// ServiceRegistryRow representa cada fila de la tabla que contiene los servicios y su orden.
type ServiceRegistryRow struct {
        Path  string
        Order int
}

// Datos simulados de la base de datos
var mockData = []ServiceRegistryRow{
        {Path: "services/NewPadronService", Order: 1},
        {Path: "services/NewReverService", Order: 2},
        {Path: "services/NewReturnService", Order: 3},
        {Path: "services/NewMyService", Order: 4},
}

func GetServiceRegistry() ([]ServiceRegistryRow, error) <span class="cov0" title="0">{
        // Ordenar los registros por el campo `Order`
        sort.Slice(mockData, func(i, j int) bool </span><span class="cov0" title="0">{
                return mockData[i].Order &lt; mockData[j].Order
        }</span>)
        <span class="cov0" title="0">return mockData, nil</span>
}
</pre>

		<pre class="file" id="file21" style="display: none">package factories

import (
        "fmt"
        "go-fiber-core/internal/database/models"
        "math/rand"
        "time"

        "gorm.io/datatypes"
        "gorm.io/gorm"
)

func CreateBulkProcessDetails(db *gorm.DB, bulkProcessID uint, count int) ([]models.BulkProcessDetail, error) <span class="cov0" title="0">{
        var details []models.BulkProcessDetail
        customerId := rand.Intn(1000)
        for i := 0; i &lt; count; i++ </span><span class="cov0" title="0">{
                infoJSON := datatypes.JSON([]byte(`{"example": "data"}`))
                detail := models.BulkProcessDetail{
                        BulkProcessID:    bulkProcessID,
                        UniqueIdentifier: generateUniqueIdentifier(),
                        CustomerID:       &amp;customerId,
                        Info:             infoJSON,
                        StatusCode:       rand.Intn(5) + 1,
                        CreatedAt:        time.Now(),
                        UpdatedAt:        time.Now(),
                }
                details = append(details, detail)
        }</span>

        <span class="cov0" title="0">if err := db.Create(&amp;details).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return details, nil</span>
}

func generateUniqueIdentifier() string <span class="cov0" title="0">{
        // Generar un string con la fecha actual + un n√∫mero aleatorio de 2 d√≠gitos
        return time.Now().Format("20060102150") + fmt.Sprintf("%02d", rand.Intn(100))
}</span>
</pre>

		<pre class="file" id="file22" style="display: none">package factories

import (
        "go-fiber-core/internal/database/models"
        "math/rand"
        "time"

        "gorm.io/gorm"
)

func CreateBulkProcess(db *gorm.DB, count int) ([]models.BulkProcess, error) <span class="cov0" title="0">{
        var processes []models.BulkProcess

        // Generar los registros de proceso
        for i := 0; i &lt; count; i++ </span><span class="cov0" title="0">{
                instanceRandow := rand.New(rand.NewSource(time.Now().UnixNano()))
                refCode := instanceRandow.Intn(100) // Aleatorio entre 0 y 99

                // Crear un proceso con datos aleatorios
                process := models.BulkProcess{
                        ProcessStatusCode: rand.Intn(5) + 1, // Aleatorio entre 1 y 5
                        StatusCode:        rand.Intn(3) + 1, // Aleatorio entre 1 y 3
                        RefCode:           &amp;refCode,         // Aleatorio entre 0 y 99
                        UserID:            rand.Intn(1000),  // Aleatorio entre 0 y 999
                        CreatedAt:         time.Now(),
                        UpdatedAt:         time.Now(),
                }

                // Usar punteros cuando corresponda (por ejemplo, si UserID es *int en el modelo)
                // Ejemplo:
                // process.UserID = &amp;userID

                // Agregar proceso a la lista
                processes = append(processes, process)
        }</span>

        // Insertar los registros en la base de datos
        <span class="cov0" title="0">if err := db.Create(&amp;processes).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return processes, nil</span>
}
</pre>

		<pre class="file" id="file23" style="display: none">package migrations

import (
        "database/sql"
        "fmt"
        "log"
        "os"
        "path/filepath"
        "strings"

        // Se importa el paquete 'gorm' que contiene el 'GormConnectService'.
        "go-fiber-core/internal/database/connections/gorm"
        "go-fiber-core/internal/dtos/config"

        goose "github.com/pressly/goose/v3"
)

// MigrationService gestiona las operaciones de migraci√≥n de la base de datos.
type MigrationService struct {
        DB             *sql.DB
        migrationsPath string
}

// MigrationServiceInterface define los m√©todos disponibles para el servicio de migraciones.
type MigrationServiceInterface interface {
        Create(name string) error
        CurrentVersion() (int64, error)
        Up() error
        Down(step int) error
        DownToZero() error
        Refresh() error
        PrintStatus() error
}

// NewMigrationService crea una nueva instancia del servicio de migraciones.
func NewMigrationService(multiConfig config.MultiDatabaseConfig) (*MigrationService, func(), error) <span class="cov0" title="0">{
        // CAMBIO: En lugar de una f√°brica, creamos el GormConnectService completo.
        gormService, err := gorm.NewGormConnectService(multiConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("no se pudo crear el GormConnectService para las migraciones: %w", err)
        }</span>

        // CAMBIO: Obtenemos el *sql.DB espec√≠fico de la conexi√≥n de ESCRITURA.
        // Las migraciones SIEMPRE deben ejecutarse sobre la base de datos principal.
        <span class="cov0" title="0">sqlDB := gormService.GetWriteSQLDB()
        if sqlDB == nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("se obtuvo un puntero nulo para la conexi√≥n de escritura de la base de datos")
        }</span>

        // Obtenemos la ruta de las migraciones bas√°ndonos en el driver de la BD de escritura.
        <span class="cov0" title="0">writeConfig := multiConfig.Gorm.Write
        migrationsPath, err := getMigrationsPath(writeConfig.Driver)
        if err != nil </span><span class="cov0" title="0">{
                _ = gormService.Close() // Cerramos el servicio si no encontramos la ruta.
                return nil, nil, fmt.Errorf("error al obtener la ruta de las migraciones: %w", err)
        }</span>
        <span class="cov0" title="0">log.Printf("Usando migraciones desde: %s", migrationsPath)

        // CAMBIO: La funci√≥n de limpieza ahora cierra el servicio GORM completo.
        cleanup := func() </span><span class="cov0" title="0">{
                log.Println("Cerrando GormConnectService de migraciones...")
                if err := gormService.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error al cerrar el GormConnectService de migraciones: %v", err)
                }</span>
        }

        <span class="cov0" title="0">return &amp;MigrationService{
                DB:             sqlDB,
                migrationsPath: migrationsPath,
        }, cleanup, nil</span>
}

// --- El resto de los m√©todos no necesita ning√∫n cambio ---

// Create genera un nuevo archivo de migraci√≥n SQL.
func (m *MigrationService) Create(name string) error <span class="cov0" title="0">{
        return goose.Create(nil, m.migrationsPath, name, "sql")
}</span>

// CurrentVersion devuelve la versi√≥n actual de la base de datos.
func (m *MigrationService) CurrentVersion() (int64, error) <span class="cov0" title="0">{
        return goose.GetDBVersion(m.DB)
}</span>

// Up aplica todas las migraciones pendientes.
func (m *MigrationService) Up() error <span class="cov0" title="0">{
        return goose.Up(m.DB, m.migrationsPath)
}</span>

// Down revierte la √∫ltima migraci√≥n o un n√∫mero de pasos especificado.
func (m *MigrationService) Down(step int) error <span class="cov0" title="0">{
        if step == 0 </span><span class="cov0" title="0">{
                return m.DownToZero()
        }</span>
        <span class="cov0" title="0">if step &lt; 1 </span><span class="cov0" title="0">{
                step = 1
        }</span>
        <span class="cov0" title="0">for i := 0; i &lt; step; i++ </span><span class="cov0" title="0">{
                if err := goose.Down(m.DB, m.migrationsPath); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error revirtiendo migraci√≥n #%d: %w", i+1, err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// DownToZero revierte todas las migraciones.
func (m *MigrationService) DownToZero() error <span class="cov0" title="0">{
        return goose.DownTo(m.DB, m.migrationsPath, 0)
}</span>

// Refresh revierte todas las migraciones y las vuelve a aplicar.
func (m *MigrationService) Refresh() error <span class="cov0" title="0">{
        if err := m.DownToZero(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return m.Up()</span>
}

// PrintStatus muestra el estado de todas las migraciones.
func (m *MigrationService) PrintStatus() error <span class="cov0" title="0">{
        return goose.Status(m.DB, m.migrationsPath)
}</span>

// getMigrationsPath construye la ruta al directorio de migraciones.
func getMigrationsPath(driver string) (string, error) <span class="cov0" title="0">{
        wd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">path := filepath.Join(wd, "internal", "database", "migrations", strings.ToLower(driver))
        if _, err := os.Stat(path); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return "", fmt.Errorf("el directorio de migraciones no existe para el driver '%s': %s", driver, path)
        }</span>
        <span class="cov0" title="0">return path, nil</span>
}
</pre>

		<pre class="file" id="file24" style="display: none">package models

import (
        "time"

        "gorm.io/gorm"
)

// TableName especifica el nombre de la tabla en la base de datos
func (BulkProcess) TableName() string <span class="cov0" title="0">{
        return "bulk_process" // Aseg√∫rate de que coincide con el nombre real en la base de datos
}</span>

// BulkProcess representa un proceso masivo en la base de datos
type BulkProcess struct {
        ID                uint           `gorm:"primaryKey"`
        ProcessStatusCode int            `gorm:"not null;index"`
        StatusCode        int            `gorm:"not null;index"`
        RefCode           *int           `gorm:"index"`
        UserID            int            `gorm:"not null;index"`
        CreatedAt         time.Time      `gorm:"default:now()"`
        UpdatedAt         time.Time      `gorm:"default:now()"`
        DeletedAt         gorm.DeletedAt `gorm:"index"`

        Details []BulkProcessDetail `gorm:"foreignKey:BulkProcessID;constraint:OnDelete:CASCADE"`
}
</pre>

		<pre class="file" id="file25" style="display: none">package models

import (
        "time"

        "gorm.io/datatypes"
        "gorm.io/gorm"
)

// TableName especifica el nombre de la tabla en la base de datos
func (BulkProcessDetail) TableName() string <span class="cov0" title="0">{
        return "bulk_process_details" // Aseg√∫rate de que coincide con el nombre real en la base de datos
}</span>

// BulkProcessDetail representa los detalles de un proceso masivo
type BulkProcessDetail struct {
        ID               uint           `gorm:"primaryKey"`
        BulkProcessID    uint           `gorm:"not null;index"`
        UniqueIdentifier string         `gorm:"size:15;not null"`
        CustomerID       *int           `gorm:"index"`
        Info             datatypes.JSON `gorm:"default:null"`
        StatusCode       int            `gorm:"not null;index"`
        CreatedAt        time.Time      `gorm:"default:now()"`
        UpdatedAt        time.Time      `gorm:"default:now()"`
        DeletedAt        gorm.DeletedAt `gorm:"index"`

        BulkProcess BulkProcess `gorm:"foreignKey:BulkProcessID"`
}
</pre>

		<pre class="file" id="file26" style="display: none">package seeders

import (
        "context"
        "encoding/csv"
        "errors"
        "fmt"
        "log"
        "os"
        "strconv"
        "strings"

        pgx "github.com/jackc/pgx/v5" // ‚úÖ Esta l√≠nea soluciona el error
        "github.com/jackc/pgx/v5/pgxpool"
)

// BankSeeder importa bancos desde un CSV a la base de datos.
func BankSeeder(db *pgxpool.Pool) error <span class="cov0" title="0">{
        csvFile := "internal/database/seeders/files/banks.csv"

        records, err := parseCSV(csvFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error procesando CSV: %w", err)
        }</span>

        <span class="cov0" title="0">ctx := context.Background()
        conn, err := db.Acquire(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error adquiriendo conexi√≥n del pool: %w", err)
        }</span>
        <span class="cov0" title="0">defer conn.Release()

        tx, err := conn.Begin(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error iniciando la transacci√≥n: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := tx.Rollback(ctx); err != nil &amp;&amp; !errors.Is(err, pgx.ErrTxClosed) </span><span class="cov0" title="0">{
                        log.Printf("error during tx rollback: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">_, err = tx.Exec(ctx, "TRUNCATE banks RESTART IDENTITY CASCADE;")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error truncando la tabla: %w", err)
        }</span>

        <span class="cov0" title="0">rows := make([][]any, 0, len(records)-1) // Optimizaci√≥n: preasignar capacidad

        for i, row := range records </span><span class="cov0" title="0">{
                if i == 0 </span><span class="cov0" title="0">{
                        fmt.Println("‚è© Ignorando cabecera...")
                        continue</span>
                }

                <span class="cov0" title="0">bank, err := parseBankRecord(row, i+1)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        continue</span>
                }

                <span class="cov0" title="0">rows = append(rows, []any{bank.ID, bank.Name, bank.EntityCode, bank.Enabled})</span>
        }

        <span class="cov0" title="0">if len(rows) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("üö® No hay registros v√°lidos para insertar")
        }</span>

        <span class="cov0" title="0">_, err = tx.CopyFrom(ctx, pgx.Identifier{"banks"},
                []string{"id", "name", "entity_code", "enabled"},
                pgx.CopyFromRows(rows),
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error ejecutando COPY: %w", err)
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error al confirmar la transacci√≥n: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("‚úÖ Bancos importados correctamente con COPY.")
        return nil</span>
}

// Bank representa la estructura de un banco en el CSV.
type Bank struct {
        ID         int
        Name       string
        EntityCode string
        Enabled    bool
}

// parseCSV lee y limpia el CSV.
func parseCSV(filename string) ([][]string, error) <span class="cov0" title="0">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error abriendo el archivo CSV: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("error closing file: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">reader := csv.NewReader(file)
        reader.Comma = ';'
        reader.LazyQuotes = true

        records, err := reader.ReadAll()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error leyendo el archivo CSV: %w", err)
        }</span>

        <span class="cov0" title="0">return records, nil</span>
}

// parseBankRecord convierte una fila del CSV en un `Bank`.
func parseBankRecord(row []string, lineNum int) (*Bank, error) <span class="cov0" title="0">{
        if len(row) &lt; 4 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("‚ùå L√≠nea %d: n√∫mero incorrecto de campos", lineNum)
        }</span>

        <span class="cov0" title="0">id, err := strconv.Atoi(row[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("‚ùå L√≠nea %d: ID inv√°lido '%s'", lineNum, row[0])
        }</span>

        <span class="cov0" title="0">name := strings.Trim(row[1], "'\"")
        entityCode := strings.Trim(row[2], "'\"")

        enabled, err := parseBoolSafe(row[3])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("‚ùå L√≠nea %d: 'enabled' inv√°lido '%s'", lineNum, row[3])
        }</span>

        <span class="cov0" title="0">return &amp;Bank{id, name, entityCode, enabled}, nil</span>
}

// parseBoolSafe convierte "1" en `true` y "0" en `false`, adem√°s de manejar `true/false`.
func parseBoolSafe(value string) (bool, error) <span class="cov0" title="0">{
        value = strings.TrimSpace(value)
        switch value </span>{
        case "1", "true", "TRUE":<span class="cov0" title="0">
                return true, nil</span>
        case "0", "false", "FALSE":<span class="cov0" title="0">
                return false, nil</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("valor booleano inv√°lido: %s", value)</span>
        }
}
</pre>

		<pre class="file" id="file27" style="display: none">package seeders

import (
        "fmt"
        "go-fiber-core/internal/database/factories"
        "go-fiber-core/internal/database/models"

        "gorm.io/gorm"
)

// SeedBulkProcesses crea registros en bulk_process y bulk_process_details.
func SeedBulkProcesses(db *gorm.DB) error <span class="cov0" title="0">{

        processes, err := factories.CreateBulkProcess(db, 5) // Crea 5 registros en bulk_process
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, process := range processes </span><span class="cov0" title="0">{
                _, err := factories.CreateBulkProcessDetails(db, process.ID, 10) // Crea 10 registros por cada bulk_process
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">fmt.Printf("Seeded bulk_process_id %d with 10 details\n", process.ID)</span>
        }

        // uno predefinido
        <span class="cov0" title="0">refCode := 999
        process := models.BulkProcess{
                ProcessStatusCode: 1,
                StatusCode:        100,
                RefCode:           &amp;refCode,
                UserID:            1,
        }

        if err := db.Create(&amp;process).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Datos personalizados para los hijos
        <span class="cov0" title="0">customerId := 1
        childData := []models.BulkProcessDetail{
                {BulkProcessID: process.ID, UniqueIdentifier: "ABC123", CustomerID: nil, StatusCode: 200},
                {BulkProcessID: process.ID, UniqueIdentifier: "DEF456", CustomerID: &amp;customerId, StatusCode: 201},
                {BulkProcessID: process.ID, UniqueIdentifier: "GHI789", CustomerID: nil, StatusCode: 202},
        }

        // Insertar los registros hijos
        if err := db.Create(&amp;childData).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">fmt.Printf("Seeded bulk_process_id %d with %d custom details\n", process.ID, len(childData))

        return nil</span>
}
</pre>

		<pre class="file" id="file28" style="display: none">package seeders

import (
        "flag"
        "fmt"
        "go-fiber-core/internal/appconfig"
        "go-fiber-core/internal/database/connections/gorm"
        "go-fiber-core/internal/database/connections/pgx"
        "log"
)

// SeederService maneja la ejecuci√≥n de los seeders como casos de uso.
// (Esta parte no necesita cambios)
type SeederService struct {
        seeders []func() error
}

// NewSeederService crea una nueva instancia del servicio de seeders.
func NewSeederService() *SeederService <span class="cov0" title="0">{
        return &amp;SeederService{
                seeders: []func() error{},
        }
}</span>

// AddSeeder agrega un seeder al servicio.
func (s *SeederService) AddSeeder(seeder func() error) <span class="cov0" title="0">{
        s.seeders = append(s.seeders, seeder)
}</span>

// Run ejecuta todos los seeders agregados.
func (s *SeederService) Run() error <span class="cov0" title="0">{
        for i, seeder := range s.seeders </span><span class="cov0" title="0">{
                log.Printf("Ejecutando seeder #%d...", i+1)
                if err := seeder(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("fall√≥ el seeder #%d: %w", i+1, err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// SeedDatabase inicializa las conexiones de ESCRITURA y ejecuta los seeders.
func SeedDatabase() error <span class="cov0" title="0">{
        configPath := flag.String("config", "internal/appconfig/config.yml", "Ruta al archivo de configuraci√≥n YAML")
        flag.Parse()
        appConfig := appconfig.NewAppConfig(*configPath)

        // --- CAMBIO: Se crean las conexiones de ESCRITURA ---

        // 1. Conectar a GORM y obtener la conexi√≥n de ESCRITURA.
        gormService, err := gorm.NewGormConnectService(appConfig.MultiDatabaseConfig)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error conectando con GORM para seeder: %w", err)
        }</span>
        // Usamos defer para asegurarnos de que el servicio completo se cierre.
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := gormService.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error closing GORM connection service: %v", err)
                }</span>
        }()
        // Obtenemos la conexi√≥n espec√≠fica de escritura.
        <span class="cov0" title="0">connectionGormWrite := gormService.GetWriteDB()

        // 2. Conectar a PGX usando la configuraci√≥n de ESCRITURA.
        connectionPgxWrite, err := pgx.NewPgxConnection(appConfig.MultiDatabaseConfig.Pgx.Write)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error conectando con PGX para seeder: %w", err)
        }</span>
        // Defer para el pool de PGX.
        <span class="cov0" title="0">defer connectionPgxWrite.Close()

        log.Println("Conexiones de escritura a la base de datos establecidas para los seeders.")

        // Crear el servicio de seeders
        service := NewSeederService()

        // CAMBIO: Agregar los seeders con las conexiones de escritura correspondientes.
        service.AddSeeder(func() error </span><span class="cov0" title="0">{ return SeedBulkProcesses(connectionGormWrite) }</span>)
        <span class="cov0" title="0">service.AddSeeder(func() error </span><span class="cov0" title="0">{ return BankSeeder(connectionPgxWrite) }</span>)

        // Ejecutar los seeders
        <span class="cov0" title="0">fmt.Println("üå± Ejecutando seeders...")
        if err := service.Run(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">fmt.Println("‚úÖ Seeders ejecutados exitosamente.")
        return nil</span>
}
</pre>

		<pre class="file" id="file29" style="display: none">package responses

import (
        fiber "github.com/gofiber/fiber/v2"
)

// Response es la estructura base para todas las respuestas de la API.
type Response struct {
        Status  string `json:"status"`
        Message string `json:"message"`
        Data    any    `json:"data,omitempty"`
        Errors  any    `json:"errors,omitempty"`
}

// Success genera una respuesta exitosa est√°ndar (HTTP 200).
func Success(c *fiber.Ctx, message string, data any) error <span class="cov0" title="0">{
        response := Response{
                Status:  "success",
                Message: message,
        }
        if data != nil </span><span class="cov0" title="0">{
                response.Data = data
        }</span>
        <span class="cov0" title="0">return c.JSON(response)</span>
}

// Error genera una respuesta de error gen√©rica con un c√≥digo de estado espec√≠fico.
func Error(c *fiber.Ctx, status int, message string, data ...any) error <span class="cov0" title="0">{
        response := Response{
                Status:  "error",
                Message: message,
        }
        if len(data) &gt; 0 </span><span class="cov0" title="0">{
                response.Data = data[0]
        }</span>
        <span class="cov0" title="0">return c.Status(status).JSON(response)</span>
}

// ValidationError genera una respuesta de error de validaci√≥n (HTTP 422)
// con un formato estructurado de errores por campo, similar a Laravel.
func ValidationError(c *fiber.Ctx, validationErrors map[string][]string) error <span class="cov0" title="0">{
        response := Response{
                Status:  "error",
                Message: "Los datos proporcionados no son v√°lidos.",
                Errors:  validationErrors,
        }
        return c.Status(fiber.StatusUnprocessableEntity).JSON(response)
}</span>
</pre>

		<pre class="file" id="file30" style="display: none">package handlers

import (
        "go-fiber-core/internal/domain"
        "go-fiber-core/internal/dtos/requests"
        "go-fiber-core/internal/dtos/responses"
        authService "go-fiber-core/internal/services/auth"
        "strconv"

        "github.com/gofiber/fiber/v2"
)

// Handler Interface
type AuthHandler interface {
        Login(c *fiber.Ctx) error
        Refresh(c *fiber.Ctx) error
        Logout(c *fiber.Ctx) error
}

// Handler Implementation
type authHandler struct {
        authService authService.AuthService
}

// Constructor
func NewAuthHandler(authService authService.AuthService) AuthHandler <span class="cov8" title="1">{
        return &amp;authHandler{
                authService: authService,
        }
}</span>

// DTO for refresh request
type refreshRequest struct {
        RefreshToken string `json:"refresh_token"`
}

// --- Handler Methods ---

func (h *authHandler) Login(c *fiber.Ctx) error <span class="cov8" title="1">{
        var req requests.LoginRequest
        if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                return domain.ErrInvalidArgument
        }</span>

        <span class="cov8" title="1">accessToken, refreshToken, err := h.authService.Login(c.Context(), req)
        if err != nil </span><span class="cov8" title="1">{
                // El servicio devuelve errores de negocio que el middleware traducir√°
                // (ej: credenciales inv√°lidas -&gt; 401 Unauthorized)
                return err
        }</span>

        <span class="cov8" title="1">data := fiber.Map{
                "access_token":  accessToken,
                "refresh_token": refreshToken,
        }
        return responses.Success(c, "Inicio de sesi√≥n exitoso", data)</span>
}

func (h *authHandler) Refresh(c *fiber.Ctx) error <span class="cov8" title="1">{
        var req refreshRequest
        if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                return domain.ErrInvalidArgument
        }</span>

        <span class="cov8" title="1">if req.RefreshToken == "" </span><span class="cov0" title="0">{
                return domain.ErrInvalidArgument
        }</span>

        <span class="cov8" title="1">newAccessToken, newRefreshToken, err := h.authService.Refresh(c.Context(), req.RefreshToken)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">data := fiber.Map{
                "access_token":  newAccessToken,
                "refresh_token": newRefreshToken,
        }
        return responses.Success(c, "Token refrescado exitosamente", data)</span>
}

func (h *authHandler) Logout(c *fiber.Ctx) error <span class="cov8" title="1">{
        userIDStr, ok := c.Locals("userID").(string)
        if !ok || userIDStr == "" </span><span class="cov0" title="0">{
                // Este es un error de autorizaci√≥n que el middleware de errores
                // puede traducir a un 401 si lo configuramos.
                return domain.ErrInvalidArgument
        }</span>

        <span class="cov8" title="1">userID, err := strconv.ParseUint(userIDStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return domain.ErrInvalidArgument
        }</span>

        <span class="cov8" title="1">if err := h.authService.Logout(c.Context(), userID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return responses.Success(c, "Cierre de sesi√≥n exitoso", nil)</span>
}
</pre>

		<pre class="file" id="file31" style="display: none">package handlers

import (
        "go-fiber-core/internal/domain"
        "go-fiber-core/internal/dtos"
        "go-fiber-core/internal/dtos/requests"
        "go-fiber-core/internal/dtos/responses"
        "go-fiber-core/internal/models"
        bankService "go-fiber-core/internal/services/bank"
        "strconv"

        "github.com/gofiber/fiber/v2"
)

// Handler Interface
type BankHandler interface {
        Create(c *fiber.Ctx) error
        GetAll(c *fiber.Ctx) error
        GetByID(c *fiber.Ctx) error
        Update(c *fiber.Ctx) error
        SoftDelete(c *fiber.Ctx) error
        HardDelete(c *fiber.Ctx) error
        GetAllPaginated(c *fiber.Ctx) error
        GetAllPaginatedWithRelations(c *fiber.Ctx) error
}

// Handler Implementation
type bankHandler struct {
        bankWriter bankService.BankWriter
        bankReader bankService.BankReader
}

// Constructor
func NewBankHandler(writer bankService.BankWriter, reader bankService.BankReader) BankHandler <span class="cov8" title="1">{
        return &amp;bankHandler{
                bankWriter: writer,
                bankReader: reader,
        }
}</span>

// --- Handler Methods ---

func (h *bankHandler) Create(c *fiber.Ctx) error <span class="cov8" title="1">{
        ctx := c.UserContext()
        req, ok := c.Locals("req").(*requests.CreateBankRequest)
        if !ok </span><span class="cov0" title="0">{
                return domain.ErrInvalidArgument
        }</span>

        <span class="cov8" title="1">newBank := models.Bank{
                Name:       req.Name,
                EntityCode: req.EntityCode,
                Enabled:    true,
        }

        if err := h.bankWriter.Create(ctx, &amp;newBank); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return c.Status(fiber.StatusCreated).JSON(responses.Response{
                Status:  "success",
                Message: "Banco creado exitosamente",
                Data:    newBank,
        })</span>
}

func (h *bankHandler) GetAll(c *fiber.Ctx) error <span class="cov8" title="1">{
        ctx := c.UserContext()
        banks, err := h.bankReader.GetAll(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return responses.Success(c, "Bancos obtenidos exitosamente", banks)</span>
}

func (h *bankHandler) GetByID(c *fiber.Ctx) error <span class="cov8" title="1">{
        ctx := c.UserContext()
        id, err := strconv.Atoi(c.Params("id"))
        if err != nil </span><span class="cov0" title="0">{
                return domain.ErrInvalidArgument
        }</span>

        <span class="cov8" title="1">bank, err := h.bankReader.GetByID(ctx, uint(id))
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return responses.Success(c, "Banco obtenido exitosamente", bank)</span>
}

func (h *bankHandler) Update(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()
        id, err := strconv.Atoi(c.Params("id"))
        if err != nil </span><span class="cov0" title="0">{
                return domain.ErrInvalidArgument
        }</span>

        <span class="cov0" title="0">bank, err := h.bankReader.GetByID(ctx, uint(id))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := c.BodyParser(bank); err != nil </span><span class="cov0" title="0">{
                return domain.ErrInvalidArgument
        }</span>

        <span class="cov0" title="0">if err := h.bankWriter.Update(ctx, bank); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return responses.Success(c, "Banco actualizado exitosamente", bank)</span>
}

func (h *bankHandler) SoftDelete(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()
        id, err := strconv.Atoi(c.Params("id"))
        if err != nil </span><span class="cov0" title="0">{
                return domain.ErrInvalidArgument
        }</span>
        <span class="cov0" title="0">if err := h.bankWriter.SoftDelete(ctx, uint(id)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return responses.Success(c, "Banco borrado l√≥gicamente", nil)</span>
}

func (h *bankHandler) HardDelete(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()
        id, err := strconv.Atoi(c.Params("id"))
        if err != nil </span><span class="cov0" title="0">{
                return domain.ErrInvalidArgument
        }</span>
        <span class="cov0" title="0">if err := h.bankWriter.HardDelete(ctx, uint(id)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return responses.Success(c, "Banco borrado permanentemente", nil)</span>
}

func (h *bankHandler) GetAllPaginated(c *fiber.Ctx) error <span class="cov8" title="1">{
        ctx := c.UserContext()
        var req dtos.PaginationRequest
        if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                return domain.ErrInvalidArgument
        }</span>

        <span class="cov8" title="1">response, err := h.bankReader.GetAllPaginated(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return responses.Success(c, "Bancos paginados obtenidos exitosamente", response)</span>
}

func (h *bankHandler) GetAllPaginatedWithRelations(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()
        var req dtos.PaginationRequest
        if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                return domain.ErrInvalidArgument
        }</span>

        <span class="cov0" title="0">response, err := h.bankReader.GetAllPaginatedWithRelations(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return responses.Success(c, "Bancos paginados con relaciones obtenidos exitosamente", response)</span>
}
</pre>

		<pre class="file" id="file32" style="display: none">package handlers

import (
        "go-fiber-core/internal/dtos/responses"
        "go-fiber-core/internal/services"

        "github.com/gofiber/fiber/v2"
)

// DatabaseHandler define la interfaz para el manejador de la base de datos.
type DatabaseHandler interface {
        HealthCheck(c *fiber.Ctx) error
}

// databaseHandler es la implementaci√≥n.
type databaseHandler struct {
        dbService *services.DatabaseService
}

// NewDatabaseHandler ahora acepta un puntero a DatabaseService.
func NewDatabaseHandler(dbService *services.DatabaseService) DatabaseHandler <span class="cov0" title="0">{
        return &amp;databaseHandler{
                dbService: dbService,
        }
}</span>

// HealthCheck es el √∫nico m√©todo necesario. Llama a todos los chequeos de salud
// del servicio y los agrupa en una sola respuesta.
func (h *databaseHandler) HealthCheck(c *fiber.Ctx) error <span class="cov0" title="0">{
        // Llamamos a cada uno de los m√©todos de chequeo de salud del servicio.
        gormWriteStatus := h.dbService.HealthGormWrite()
        gormReadStatus := h.dbService.HealthGormRead()
        pgxWriteStatus := h.dbService.HealthPgxWrite()
        pgxReadStatus := h.dbService.HealthPgxRead()
        redisStatus := h.dbService.HealthRedis()

        // Agregamos todos los resultados en un mapa para una respuesta clara y completa.
        fullStatus := map[string]any{
                "gorm_write": gormWriteStatus,
                "gorm_read":  gormReadStatus,
                "pgx_write":  pgxWriteStatus,
                "pgx_read":   pgxReadStatus,
                "redis":      redisStatus,
        }

        // Devuelve una respuesta estandarizada usando el helper 'Success'.
        return responses.Success(c, "Estado de las conexiones del sistema", fullStatus)
}</span>
</pre>

		<pre class="file" id="file33" style="display: none">package handlers

import (
        "go-fiber-core/internal/domain"
        "go-fiber-core/internal/dtos"
        "go-fiber-core/internal/dtos/responses"
        "go-fiber-core/internal/models"
        userService "go-fiber-core/internal/services/user"
        "strconv"

        "github.com/gofiber/fiber/v2"
)

// Request DTOs
type CreateUserRequest struct {
        Name     string `json:"name" validate:"required"`
        Email    string `json:"email" validate:"required,email"`
        Password string `json:"password" validate:"required,min=8"`
}
type UpdateUserRequest struct {
        Name  string `json:"name" validate:"required"`
        Email string `json:"email" validate:"required,email"`
}

// Handler Interface
type UserHandler interface {
        CreateUser(c *fiber.Ctx) error
        GetAllUsers(c *fiber.Ctx) error
        GetUserByID(c *fiber.Ctx) error
        UpdateUser(c *fiber.Ctx) error
        DeleteUser(c *fiber.Ctx) error
        GetAllPaginatedUsers(c *fiber.Ctx) error
}

// Handler Implementation
type userHandler struct {
        userWriter userService.UserWriter
        userReader userService.UserReader
}

// Constructor
func NewUserHandler(writer userService.UserWriter, reader userService.UserReader) UserHandler <span class="cov8" title="1">{
        return &amp;userHandler{
                userWriter: writer,
                userReader: reader,
        }
}</span>

// --- Handler Methods ---

func (h *userHandler) CreateUser(c *fiber.Ctx) error <span class="cov8" title="1">{
        ctx := c.UserContext()
        var req CreateUserRequest
        if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                return domain.ErrInvalidArgument
        }</span>

        <span class="cov8" title="1">user := &amp;models.User{
                Name:     req.Name,
                Email:    req.Email,
                Password: req.Password,
        }

        if err := h.userWriter.Create(ctx, user); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return c.Status(fiber.StatusCreated).JSON(responses.Response{
                Status:  "success",
                Message: "Usuario creado exitosamente",
                Data:    user,
        })</span>
}

func (h *userHandler) GetAllUsers(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()
        users, err := h.userReader.GetAll(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return responses.Success(c, "Usuarios obtenidos exitosamente", users)</span>
}

func (h *userHandler) GetUserByID(c *fiber.Ctx) error <span class="cov8" title="1">{
        ctx := c.UserContext()
        id, err := strconv.ParseUint(c.Params("id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return domain.ErrInvalidArgument
        }</span>

        <span class="cov8" title="1">user, err := h.userReader.GetByID(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return responses.Success(c, "Usuario obtenido exitosamente", user)</span>
}

func (h *userHandler) UpdateUser(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()
        id, err := strconv.ParseUint(c.Params("id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return domain.ErrInvalidArgument
        }</span>

        <span class="cov0" title="0">var req UpdateUserRequest
        if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                return domain.ErrInvalidArgument
        }</span>

        // El servicio se encarga de verificar si el usuario existe.
        <span class="cov0" title="0">userToUpdate := &amp;models.User{
                Name:  req.Name,
                Email: req.Email,
        }
        userToUpdate.ID = id

        if err := h.userWriter.Update(ctx, userToUpdate); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Devolvemos el objeto actualizado para confirmaci√≥n.
        <span class="cov0" title="0">return responses.Success(c, "Usuario actualizado exitosamente", userToUpdate)</span>
}

func (h *userHandler) DeleteUser(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()
        id, err := strconv.ParseUint(c.Params("id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return domain.ErrInvalidArgument
        }</span>

        <span class="cov0" title="0">if err := h.userWriter.Delete(ctx, id); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return responses.Success(c, "Usuario eliminado correctamente", nil)</span>
}

func (h *userHandler) GetAllPaginatedUsers(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()
        var req dtos.PaginationRequest
        if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                return domain.ErrInvalidArgument
        }</span>

        <span class="cov0" title="0">response, err := h.userReader.GetAllPaginated(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return responses.Success(c, "Usuarios paginados obtenidos exitosamente", response)</span>
}
</pre>

		<pre class="file" id="file34" style="display: none">package jobqueue

import (
        "context"
        "encoding/json"
        "log"
        "time"

        redis "github.com/redis/go-redis/v9"
)

func StartWorker(ctx context.Context, rdb *redis.Client, queueName string) <span class="cov0" title="0">{
        log.Println("[WORKER] Iniciando escucha en:", queueName)

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        log.Println("[WORKER] Finalizando por contexto cancelado.")
                        return</span>
                default:<span class="cov0" title="0">
                        result, err := rdb.BRPop(ctx, 5*time.Second, queueName).Result()
                        if err == redis.Nil </span><span class="cov0" title="0">{
                                continue</span>
                        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                                log.Println("error al leer de redis:", err)
                                continue</span>
                        }

                        <span class="cov0" title="0">if len(result) &lt; 2 </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">payload := result[1]
                        var job JobMessage
                        if err := json.Unmarshal([]byte(payload), &amp;job); err != nil </span><span class="cov0" title="0">{
                                log.Println("error al parsear job:", err)
                                continue</span>
                        }

                        <span class="cov0" title="0">log.Printf("[WORKER] Procesando job: %s\n", job.Type)
                        if err := HandleJob(job); err != nil </span><span class="cov0" title="0">{
                                log.Printf("[WORKER] Error ejecutando job: %v\n", err)
                        }</span> else<span class="cov0" title="0"> {
                                log.Printf("[WORKER] Job ejecutado correctamente.")
                        }</span>
                }
        }
}
</pre>

		<pre class="file" id="file35" style="display: none">package jobqueue

import (
        "fmt"
)

type JobHandler func(data []byte) error

var handlers = make(map[string]JobHandler)

func RegisterHandler(jobType string, handler JobHandler) <span class="cov0" title="0">{
        handlers[jobType] = handler
}</span>

func HandleJob(job JobMessage) error <span class="cov0" title="0">{
        handler, ok := handlers[job.Type]
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("handler no registrado para job type: %s", job.Type)
        }</span>
        <span class="cov0" title="0">return handler(job.Data)</span>
}
</pre>

		<pre class="file" id="file36" style="display: none">package jobqueue

import (
        "context"
        "encoding/json"
        "fmt"

        redis "github.com/redis/go-redis/v9"
)

// JobMessage representa la estructura de un trabajo en la cola.
type JobMessage struct {
        Type string          `json:"type"`
        Data json.RawMessage `json:"data"`
}

// Enqueuer es un servicio para encolar trabajos en Redis.
// Se crea una vez con un cliente de Redis y se reutiliza.
type Enqueuer struct {
        redisClient *redis.Client
}

// NewEnqueuer crea una nueva instancia del servicio para encolar trabajos.
// Recibe el cliente de Redis como una dependencia.
func NewEnqueuer(client *redis.Client) *Enqueuer <span class="cov0" title="0">{
        return &amp;Enqueuer{
                redisClient: client,
        }
}</span>

// Enqueue serializa y encola un nuevo trabajo en la cola principal de Redis.
func (e *Enqueuer) Enqueue(ctx context.Context, jobType string, data any) error <span class="cov0" title="0">{
        // 1. Serializar los datos espec√≠ficos del trabajo
        rawData, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error al serializar los datos del job: %w", err)
        }</span>

        // 2. Crear la estructura del mensaje del job
        <span class="cov0" title="0">job := JobMessage{
                Type: jobType,
                Data: rawData,
        }

        // 3. Serializar el mensaje completo del job
        payload, err := json.Marshal(job)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error al serializar el payload del job: %w", err)
        }</span>

        // 4. Encolar el trabajo en Redis usando el cliente que ya tiene el servicio
        <span class="cov0" title="0">return e.redisClient.RPush(ctx, "jobs:main", payload).Err()</span>
}
</pre>

		<pre class="file" id="file37" style="display: none">package logger

import (
        "fmt"
        "log"
        "os"
        "path/filepath"
        "sync"
        "time"

        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
        lumberjack "gopkg.in/natefinch/lumberjack.v2" // ‚úÖ Esta l√≠nea soluciona el error
)

var (
        loggers sync.Map // key: use-case, value: *zap.Logger
)

func GetLogger(name string) *zap.Logger <span class="cov0" title="0">{
        // Chequear si ya existe
        if logger, ok := loggers.Load(name); ok </span><span class="cov0" title="0">{
                return logger.(*zap.Logger)
        }</span>

        // Si no existe, lo crea y lo guarda
        <span class="cov0" title="0">newLogger := createLogger(name)
        loggers.Store(name, newLogger)
        return newLogger</span>
}

func createLogger(name string) *zap.Logger <span class="cov0" title="0">{
        now := time.Now().Format("2006-01-02")
        logDir := "pkg/logs"
        if err := os.MkdirAll(logDir, os.ModePerm); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("error creating log directory %s: %v", logDir, err)
        }</span>

        <span class="cov0" title="0">logPath := filepath.Join(logDir, fmt.Sprintf("%s-%s.log", name, now))

        writer := zapcore.AddSync(&amp;lumberjack.Logger{
                Filename:   logPath,
                MaxSize:    50, // MB
                MaxBackups: 7,
                MaxAge:     30,   // d√≠as
                Compress:   true, // gzip
        })

        encoder := zapcore.NewJSONEncoder(zapcore.EncoderConfig{
                TimeKey:      "timestamp",
                LevelKey:     "level",
                MessageKey:   "message",
                CallerKey:    "caller",
                EncodeTime:   customTimeEncoder,
                EncodeLevel:  zapcore.CapitalLevelEncoder,
                EncodeCaller: zapcore.ShortCallerEncoder,
        })

        core := zapcore.NewCore(encoder, writer, zapcore.DebugLevel)

        return zap.New(core, zap.AddCaller())</span>
}

func customTimeEncoder(t time.Time, enc zapcore.PrimitiveArrayEncoder) <span class="cov0" title="0">{
        enc.AppendString(t.Format("2006-01-02 15:04:05"))
}</span>
</pre>

		<pre class="file" id="file38" style="display: none">package middleware

import (
        "go-fiber-core/internal/services/auth"
        "strings"

        fiber "github.com/gofiber/fiber/v2"
        jwt "github.com/golang-jwt/jwt/v5"
)

// AuthMiddleware crea un manejador de Fiber para proteger rutas.
// ‚úÖ Depende de la INTERFAZ TokenService, no de la implementaci√≥n concreta.
func AuthMiddleware(tokenService auth.TokenService) fiber.Handler <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                authHeader := c.Get("Authorization")
                if authHeader == "" </span><span class="cov8" title="1">{
                        return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{"error": "falta la cabecera de autorizaci√≥n"})
                }</span>

                <span class="cov8" title="1">parts := strings.Split(authHeader, " ")
                if len(parts) != 2 || parts[0] != "Bearer" </span><span class="cov8" title="1">{
                        return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{"error": "formato de token inv√°lido"})
                }</span>

                <span class="cov8" title="1">tokenString := parts[1]

                // ‚úÖ Usamos el m√©todo ValidateToken que definimos en nuestra interfaz.
                token, err := tokenService.ValidateToken(tokenString)
                if err != nil || !token.Valid </span><span class="cov8" title="1">{
                        return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{"error": "token inv√°lido o expirado"})
                }</span>

                // Extraemos las "claims" (la informaci√≥n dentro del token).
                <span class="cov8" title="1">claims, ok := token.Claims.(jwt.MapClaims)
                if !ok </span><span class="cov8" title="1">{
                        return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{"error": "formato de claims de token inv√°lido"})
                }</span>

                // El "subject" (sub) del token JWT es el ID del usuario.
                <span class="cov8" title="1">userID, ok := claims["sub"].(string)
                if !ok </span><span class="cov8" title="1">{
                        return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{"error": "claim de ID de usuario inv√°lida"})
                }</span>

                // Guardamos la informaci√≥n del usuario en el contexto para usarla en los handlers.
                <span class="cov8" title="1">c.Locals("userID", userID)

                return c.Next()</span>
        }
}
</pre>

		<pre class="file" id="file39" style="display: none">package middleware

import (
        "errors"
        "go-fiber-core/internal/domain" // Importamos nuestros errores
        "go-fiber-core/internal/dtos/responses"
        "log"

        "github.com/gofiber/fiber/v2"
)

func ErrorHandler(c *fiber.Ctx, err error) error <span class="cov0" title="0">{
        // Revisa el tipo de error y decide qu√© respuesta enviar.
        switch </span>{
        case errors.Is(err, domain.ErrNotFound):<span class="cov0" title="0">
                return responses.Error(c, fiber.StatusNotFound, err.Error())</span>

        case errors.Is(err, domain.ErrInvalidArgument):<span class="cov0" title="0">
                return responses.Error(c, fiber.StatusBadRequest, err.Error())</span>

        case errors.Is(err, domain.ErrAuthentication):<span class="cov0" title="0">
                return responses.Error(c, fiber.StatusUnauthorized, err.Error())</span>

        // Y as√≠ para otros errores personalizados...

        default:<span class="cov0" title="0">
                // Si es un error que no esperamos, lo registramos para depuraci√≥n
                // y devolvemos un error gen√©rico 500.
                log.Printf("Error no manejado en la API: %v", err)
                return responses.Error(c, fiber.StatusInternalServerError, "Ha ocurrido un error inesperado en el servidor.")</span>
        }
}
</pre>

		<pre class="file" id="file40" style="display: none">package middleware

import (
        "log"
        "time"

        fiber "github.com/gofiber/fiber/v2"
        redis "github.com/redis/go-redis/v9"
)

const rateLimitKeyPrefix = "rate_limit:"

// RateLimitConfig permite configurar el middleware
type RateLimitConfig struct {
        Limit  int64
        Window time.Duration
}

// RateLimitMiddleware aplica un rate limit por IP o cabecera de forma at√≥mica.
func RateLimitMiddleware(redisClient *redis.Client, config RateLimitConfig) fiber.Handler <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                // 1. Usa un identificador fiable: cabecera para usuarios autenticados o IP para an√≥nimos.
                clientIdentifier := c.Get("X-Client-Code") // Ideal para una API Key
                if clientIdentifier == "" </span><span class="cov8" title="1">{
                        clientIdentifier = c.IP()
                }</span>

                <span class="cov8" title="1">key := rateLimitKeyPrefix + clientIdentifier

                // 2. Utiliza el contexto de la petici√≥n de Fiber.
                ctx := c.Context()

                // 3. Usa una pipeline de Redis para ejecutar comandos de forma at√≥mica.
                var countCmd *redis.IntCmd
                _, err := redisClient.Pipelined(ctx, func(pipe redis.Pipeliner) error </span><span class="cov8" title="1">{
                        // Incrementa el contador. Si la clave no existe, la crea con valor 1.
                        countCmd = pipe.Incr(ctx, key)
                        // Establece la expiraci√≥n en cada petici√≥n para implementar una ventana deslizante.
                        pipe.Expire(ctx, key, config.Window)
                        return nil
                }</span>)

                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error al ejecutar la pipeline de Redis: %v", err)
                        return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{"error": "Internal server error"})
                }</span>

                // Obtenemos el valor actual del contador
                <span class="cov8" title="1">count, err := countCmd.Result()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error al obtener el resultado del contador: %v", err)
                        return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{"error": "Internal server error"})
                }</span>

                // 4. Comprueba si se ha excedido el l√≠mite.
                <span class="cov8" title="1">if count &gt; config.Limit </span><span class="cov8" title="1">{
                        return c.Status(fiber.StatusTooManyRequests).JSON(fiber.Map{
                                "error": "Rate limit exceeded",
                        })
                }</span>

                // Si todo est√° bien, pasa a la siguiente ruta.
                <span class="cov8" title="1">return c.Next()</span>
        }
}
</pre>

		<pre class="file" id="file41" style="display: none">package models

import (
        "time"

        "gorm.io/gorm"
)

func (Bank) TableName() string <span class="cov0" title="0">{
        return "banks"
}</span>

type Bank struct {
        ID         uint           `gorm:"primaryKey" json:"id"`
        Name       string         `gorm:"size:255;not null" json:"name" validate:"required,min=3,max=255"`
        EntityCode string         `gorm:"size:50;not null;unique" json:"entity_code" validate:"required,alphanum,max=50"`
        Enabled    bool           `gorm:"default:true" json:"enabled"`
        DeletedAt  gorm.DeletedAt `gorm:"index" json:"-" filter:"date"`
        CreatedAt  time.Time      `gorm:"index" json:"created_at" filter:"date"`
        UpdatedAt  time.Time      `json:"updated_at" filter:"date"`
}
</pre>

		<pre class="file" id="file42" style="display: none">package models

import (
        "time"
)

// RefreshToken almacena los tokens de refresco para poder invalidarlos.
type RefreshToken struct {
        ID        uint      `gorm:"primarykey"`
        UserID    uint64    `gorm:"not null;index"` // Coincide con el tipo de ID del usuario
        Token     string    `gorm:"type:varchar(512);unique;not null"`
        ExpiresAt time.Time `gorm:"not null"`

        User      User `gorm:"foreignKey:UserID"`
        CreatedAt time.Time
}

// TableName especifica el nombre de la tabla en la base de datos
func (RefreshToken) TableName() string <span class="cov0" title="0">{
        return "refresh_tokens"
}</span>
</pre>

		<pre class="file" id="file43" style="display: none">package models

import (
        "time"

        "gorm.io/gorm"
)

// User define el modelo para la tabla de usuarios en la base de datos.
type User struct {
        // Usamos uint64 para que coincida con BIGSERIAL/BIGINT de la base de datos.
        ID uint64 `gorm:"primarykey" json:"id"`

        Name     string `gorm:"type:varchar(255);not null" json:"name"`
        Email    string `gorm:"type:varchar(255);unique;not null" json:"email"`
        Password string `gorm:"type:varchar(255);not null" json:"-"` // Oculto en las respuestas JSON
        IsActive bool   `gorm:"not null;default:true" json:"is_active"`

        // GORM maneja autom√°ticamente la creaci√≥n y actualizaci√≥n de estos campos.
        CreatedAt time.Time `json:"created_at" filter:"date"`
        UpdatedAt time.Time `json:"updated_at" filter:"date"`

        // GORM usa este campo para el "soft delete", creando un √≠ndice como se especific√≥.
        DeletedAt gorm.DeletedAt `gorm:"index" json:"-" filter:"date"`
}

// TableName especifica expl√≠citamente el nombre de la tabla para este modelo.
func (User) TableName() string <span class="cov0" title="0">{
        return "users"
}</span>
</pre>

		<pre class="file" id="file44" style="display: none">package bank

import (
        "context"
        "go-fiber-core/internal/dtos"
        "go-fiber-core/internal/models"
        "go-fiber-core/internal/services/pagination"

        "gorm.io/gorm"
)

// BankPaginationRepository define la interfaz para las consultas complejas de bancos.
type BankPaginationRepository interface {
        GetAllPaginated(ctx context.Context, db *gorm.DB, req dtos.PaginationRequest) (*dtos.PaginationResponse[models.Bank], error)
        GetAllPaginatedWithRelations(ctx context.Context, db *gorm.DB, req dtos.PaginationRequest) (*dtos.PaginationResponse[models.Bank], error)
        GetAllFiltered(ctx context.Context, db *gorm.DB, req dtos.PaginationRequest) ([]models.Bank, error)
}

// bankPaginationRepository es la implementaci√≥n de la interfaz de paginaci√≥n.
type bankPaginationRepository struct {
        paginationService *pagination.PaginationService[models.Bank]
}

// NewBankPaginationRepository es el constructor que inyecta el servicio de paginaci√≥n.
func NewBankPaginationRepository(ps *pagination.PaginationService[models.Bank]) BankPaginationRepository <span class="cov0" title="0">{
        return &amp;bankPaginationRepository{
                paginationService: ps,
        }
}</span>

func (r *bankPaginationRepository) GetAllPaginated(ctx context.Context, db *gorm.DB, req dtos.PaginationRequest) (*dtos.PaginationResponse[models.Bank], error) <span class="cov0" title="0">{
        return r.paginationService.Execute(db.WithContext(ctx), req, nil, nil)
}</span>

func (r *bankPaginationRepository) GetAllPaginatedWithRelations(ctx context.Context, db *gorm.DB, req dtos.PaginationRequest) (*dtos.PaginationResponse[models.Bank], error) <span class="cov0" title="0">{
        modifier := func(query *gorm.DB) *gorm.DB </span><span class="cov0" title="0">{
                // Aqu√≠ puedes precargar relaciones si es necesario
                // return query.Preload("AlgunaRelacion")
                return query
        }</span>
        <span class="cov0" title="0">extrasCalculator := func(query *gorm.DB) (map[string]any, error) </span><span class="cov0" title="0">{
                // Ejemplo de c√°lculo de extras
                // var totalBalance float64
                // err := query.Session(&amp;gorm.Session{}).Model(&amp;models.Bank{}).Select("sum(balance)").Scan(&amp;totalBalance).Error
                // if err != nil {
                //         return nil, err
                // }
                return map[string]any{
                        "total_balance": 45675345,
                }, nil
        }</span>
        <span class="cov0" title="0">return r.paginationService.Execute(db.WithContext(ctx), req, modifier, extrasCalculator)</span>
}

func (r *bankPaginationRepository) GetAllFiltered(ctx context.Context, db *gorm.DB, req dtos.PaginationRequest) ([]models.Bank, error) <span class="cov0" title="0">{
        var banks []models.Bank
        dateColumns := r.paginationService.GetDateColumnsFromModel(models.Bank{})
        query := db.WithContext(ctx).Model(&amp;models.Bank{})

        query = r.paginationService.ApplyFilters(query, req, dateColumns)
        query = r.paginationService.ApplyOrder(query, req)

        if err := query.Find(&amp;banks).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return banks, nil</span>
}
</pre>

		<pre class="file" id="file45" style="display: none">package bank

import (
        "context"
        "errors"
        "go-fiber-core/internal/models"

        "gorm.io/gorm"
)

// BankRepository define la interfaz para las operaciones CRUD de bancos.
type BankRepository interface {
        Create(ctx context.Context, db *gorm.DB, bank *models.Bank) error
        GetAll(ctx context.Context, db *gorm.DB) ([]models.Bank, error)
        GetByID(ctx context.Context, db *gorm.DB, id uint) (*models.Bank, error)
        Update(ctx context.Context, db *gorm.DB, bank *models.Bank) error
        SoftDelete(ctx context.Context, db *gorm.DB, id uint) error
        HardDelete(ctx context.Context, db *gorm.DB, id uint) error
}

// bankRepository es la implementaci√≥n de la interfaz CRUD.
type bankRepository struct{}

// NewBankRepository es el constructor del repositorio CRUD. No tiene dependencias.
func NewBankRepository() BankRepository <span class="cov0" title="0">{
        return &amp;bankRepository{}
}</span>

func (r *bankRepository) Create(ctx context.Context, db *gorm.DB, bank *models.Bank) error <span class="cov0" title="0">{
        return db.WithContext(ctx).Create(bank).Error
}</span>

func (r *bankRepository) GetAll(ctx context.Context, db *gorm.DB) ([]models.Bank, error) <span class="cov0" title="0">{
        var banks []models.Bank
        err := db.WithContext(ctx).Find(&amp;banks).Error
        return banks, err
}</span>

func (r *bankRepository) GetByID(ctx context.Context, db *gorm.DB, id uint) (*models.Bank, error) <span class="cov0" title="0">{
        var bank models.Bank
        if err := db.WithContext(ctx).First(&amp;bank, id).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, gorm.ErrRecordNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;bank, nil</span>
}

func (r *bankRepository) Update(ctx context.Context, db *gorm.DB, bank *models.Bank) error <span class="cov0" title="0">{
        return db.WithContext(ctx).Save(bank).Error
}</span>

func (r *bankRepository) SoftDelete(ctx context.Context, db *gorm.DB, id uint) error <span class="cov0" title="0">{
        return db.WithContext(ctx).Delete(&amp;models.Bank{}, id).Error
}</span>

func (r *bankRepository) HardDelete(ctx context.Context, db *gorm.DB, id uint) error <span class="cov0" title="0">{
        return db.WithContext(ctx).Unscoped().Delete(&amp;models.Bank{}, id).Error
}</span>
</pre>

		<pre class="file" id="file46" style="display: none">package refreshtoken

import (
        "context"
        "go-fiber-core/internal/models"

        "gorm.io/gorm"
)

type RefreshTokenRepository interface {
        Create(ctx context.Context, db *gorm.DB, token *models.RefreshToken) error
        GetByToken(ctx context.Context, db *gorm.DB, token string) (*models.RefreshToken, error)
        DeleteByUserID(ctx context.Context, db *gorm.DB, userID uint64) error
}

type refreshTokenRepository struct{}

func NewRefreshTokenRepository() RefreshTokenRepository <span class="cov0" title="0">{
        return &amp;refreshTokenRepository{}
}</span>

func (r *refreshTokenRepository) Create(ctx context.Context, db *gorm.DB, token *models.RefreshToken) error <span class="cov0" title="0">{
        return db.WithContext(ctx).Create(token).Error
}</span>

func (r *refreshTokenRepository) GetByToken(ctx context.Context, db *gorm.DB, token string) (*models.RefreshToken, error) <span class="cov0" title="0">{
        var refreshToken models.RefreshToken
        // Usamos First para que devuelva un error si no se encuentra, lo cual es el comportamiento deseado.
        err := db.WithContext(ctx).Where("token = ?", token).First(&amp;refreshToken).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err // Devuelve el error original de GORM (ej. gorm.ErrRecordNotFound)
        }</span>
        <span class="cov0" title="0">return &amp;refreshToken, nil</span>
}

func (r *refreshTokenRepository) DeleteByUserID(ctx context.Context, db *gorm.DB, userID uint64) error <span class="cov0" title="0">{
        // Elimina todos los refresh tokens asociados a un usuario (cierra todas sus sesiones)
        return db.WithContext(ctx).Where("user_id = ?", userID).Delete(&amp;models.RefreshToken{}).Error
}</span>
</pre>

		<pre class="file" id="file47" style="display: none">package user

import (
        "context"
        "go-fiber-core/internal/dtos"
        "go-fiber-core/internal/models"
        "go-fiber-core/internal/services/pagination"

        "gorm.io/gorm"
)

// UserPaginationRepository define la interfaz para la paginaci√≥n de usuarios.
type UserPaginationRepository interface {
        GetAllPaginated(ctx context.Context, db *gorm.DB, req dtos.PaginationRequest) (*dtos.PaginationResponse[models.User], error)
}

// userPaginationRepository es la implementaci√≥n de la interfaz.
type userPaginationRepository struct {
        paginationService *pagination.PaginationService[models.User]
}

// NewUserPaginationRepository es el constructor que inyecta el servicio de paginaci√≥n.
func NewUserPaginationRepository(ps *pagination.PaginationService[models.User]) UserPaginationRepository <span class="cov0" title="0">{
        return &amp;userPaginationRepository{
                paginationService: ps,
        }
}</span>

// GetAllPaginated implementa el m√©todo de paginaci√≥n.
func (r *userPaginationRepository) GetAllPaginated(ctx context.Context, db *gorm.DB, req dtos.PaginationRequest) (*dtos.PaginationResponse[models.User], error) <span class="cov0" title="0">{
        return r.paginationService.Execute(db.WithContext(ctx), req, nil, nil)
}</span>
</pre>

		<pre class="file" id="file48" style="display: none">package user

import (
        "context"
        "errors"
        "go-fiber-core/internal/models"

        "gorm.io/gorm"
)

// UserRepository define la interfaz para las operaciones CRUD de usuarios.
type UserRepository interface {
        Create(ctx context.Context, db *gorm.DB, user *models.User) error
        GetAll(ctx context.Context, db *gorm.DB) ([]models.User, error)
        GetByID(ctx context.Context, db *gorm.DB, id uint64) (*models.User, error)
        GetByEmail(ctx context.Context, db *gorm.DB, email string) (*models.User, error)
        Update(ctx context.Context, db *gorm.DB, user *models.User) error
        SoftDelete(ctx context.Context, db *gorm.DB, id uint64) error
}

// userRepository es la implementaci√≥n de la interfaz.
type userRepository struct{}

// NewUserRepository es el constructor para el repositorio CRUD.
func NewUserRepository() UserRepository <span class="cov0" title="0">{
        return &amp;userRepository{}
}</span>

func (r *userRepository) Create(ctx context.Context, db *gorm.DB, user *models.User) error <span class="cov0" title="0">{
        return db.WithContext(ctx).Create(user).Error
}</span>

func (r *userRepository) GetAll(ctx context.Context, db *gorm.DB) ([]models.User, error) <span class="cov0" title="0">{
        var users []models.User
        err := db.WithContext(ctx).Find(&amp;users).Error
        return users, err
}</span>

func (r *userRepository) GetByID(ctx context.Context, db *gorm.DB, id uint64) (*models.User, error) <span class="cov0" title="0">{
        var user models.User
        if err := db.WithContext(ctx).First(&amp;user, id).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, gorm.ErrRecordNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;user, nil</span>
}

func (r *userRepository) GetByEmail(ctx context.Context, db *gorm.DB, email string) (*models.User, error) <span class="cov0" title="0">{
        var user models.User
        if err := db.WithContext(ctx).Where("email = ?", email).First(&amp;user).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, gorm.ErrRecordNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;user, nil</span>
}

func (r *userRepository) Update(ctx context.Context, db *gorm.DB, user *models.User) error <span class="cov0" title="0">{
        return db.WithContext(ctx).Save(user).Error
}</span>

func (r *userRepository) SoftDelete(ctx context.Context, db *gorm.DB, id uint64) error <span class="cov0" title="0">{
        return db.WithContext(ctx).Delete(&amp;models.User{}, id).Error
}</span>
</pre>

		<pre class="file" id="file49" style="display: none">// internal/routes/auth_routes.go
package routes

import (
        "go-fiber-core/internal/handlers"

        fiber "github.com/gofiber/fiber/v2"
)

// SetupAuthRoutes ahora acepta un fiber.Router y la interfaz del handler.
func RegisterAuthRoutes(router fiber.Router, authHandler handlers.AuthHandler) <span class="cov0" title="0">{
        auth := router.Group("/auth")

        auth.Post("/login", authHandler.Login)
        auth.Post("/refresh", authHandler.Refresh)
        auth.Post("/logout", authHandler.Logout)
}</span>
</pre>

		<pre class="file" id="file50" style="display: none">package routes

import (
        "go-fiber-core/internal/dtos/requests"
        "go-fiber-core/internal/handlers"
        "go-fiber-core/internal/utils" // Importado para usar el middleware de validaci√≥n

        fiber "github.com/gofiber/fiber/v2"
)

// RegisterBankRoutes define todos los endpoints relacionados con el recurso de Bancos.
// Recibe sus dependencias (router y handler) en lugar de crearlas.
func RegisterBankRoutes(router fiber.Router, bankHandler handlers.BankHandler) <span class="cov0" title="0">{
        // Agrupamos todas las rutas de bancos bajo el prefijo "/banks"
        bankGroup := router.Group("/banks")

        // --- RUTA DE CREACI√ìN ---
        // Se aplica el middleware de validaci√≥n ANTES de llamar al handler.
        // 1. La petici√≥n llega a "/create".
        // 2. utils.Validate se ejecuta, parsea el body en un CreateBankRequest y lo valida.
        // 3. Si la validaci√≥n es exitosa, llama a bankHandler.Create. Si no, devuelve un error 422.
        bankGroup.Post(
                "/create",
                utils.Validate(new(requests.CreateBankRequest)),
                bankHandler.Create,
        )

        // --- OTRAS RUTAS CRUD ---
        // Estas rutas no necesitan el middleware de validaci√≥n del body, por lo que se mantienen como estaban.
        bankGroup.Get("/", bankHandler.GetAll)
        bankGroup.Get("/:id", bankHandler.GetByID)
        bankGroup.Put("/edit/:id", bankHandler.Update) // NOTA: Esta ruta probablemente tambi√©n necesite un middleware de validaci√≥n similar.
        bankGroup.Delete("/:id", bankHandler.SoftDelete)
        bankGroup.Delete("/hard/:id", bankHandler.HardDelete)
        bankGroup.Post("/paginated", bankHandler.GetAllPaginated)
        bankGroup.Post("/paginated-v2", bankHandler.GetAllPaginatedWithRelations)
}</span>
</pre>

		<pre class="file" id="file51" style="display: none">package routes

import (
        "go-fiber-core/internal/handlers"

        "github.com/gofiber/fiber/v2"
)

// RegisterDatabaseRoutes ahora recibe el handler ya creado y registra la ruta de health check.
// Ya no necesita la configuraci√≥n ni las conexiones, siguiendo el principio de Inyecci√≥n de Dependencias.
func RegisterDatabaseRoutes(router fiber.Router, dbHandler handlers.DatabaseHandler) <span class="cov0" title="0">{
        // CAMBIO: Se registra una √∫nica ruta '/health' que devuelve el estado de todas las conexiones.
        // Esta es una pr√°ctica est√°ndar para los endpoints de monitoreo.
        router.Get("/health", dbHandler.HealthCheck)
}</span>
</pre>

		<pre class="file" id="file52" style="display: none">// internal/routes/user_routes.go

package routes

import (
        "go-fiber-core/internal/handlers"

        fiber "github.com/gofiber/fiber/v2"
)

// SetupUserRoutes ahora recibe el UserHandler que crearemos en nuestro archivo principal.
func RegisterUserRoutes(router fiber.Router, userHandler handlers.UserHandler) <span class="cov0" title="0">{
        users := router.Group("/users")

        users.Post("/", userHandler.CreateUser)
        users.Get("/", userHandler.GetAllUsers)
        users.Get("/:id", userHandler.GetUserByID)
        users.Put("/:id", userHandler.UpdateUser)
        users.Delete("/:id", userHandler.DeleteUser)

        // pendiente cambiar password

        // Ruta para obtener usuarios paginados
        users.Post("/paginated", userHandler.GetAllPaginatedUsers)
}</span>
</pre>

		<pre class="file" id="file53" style="display: none">package server

import (
        "go-fiber-core/internal/handlers"
        "go-fiber-core/internal/middleware"
        "go-fiber-core/internal/models"
        "go-fiber-core/internal/utils"

        // CAMBIO: Se importan los paquetes espec√≠ficos de cada repositorio.
        bankRepo "go-fiber-core/internal/repositories/bank"
        refreshTokenRepo "go-fiber-core/internal/repositories/refreshtoken"
        userRepo "go-fiber-core/internal/repositories/user"
        "go-fiber-core/internal/routes"
        "go-fiber-core/internal/services"
        "go-fiber-core/internal/services/auth"
        authService "go-fiber-core/internal/services/auth"
        bankService "go-fiber-core/internal/services/bank"
        "go-fiber-core/internal/services/pagination"
        userService "go-fiber-core/internal/services/user"
        "net"

        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/fiber/v2/middleware/cors"
)

// RegisterRoutes inicializa y configura todas las rutas de la aplicaci√≥n.
func (s *FiberServer) RegisterRoutes() <span class="cov0" title="0">{
        // --- CONFIGURACI√ìN DE MIDDLEWARES Y VALIDATOR ---
        s.App.Use(cors.New(cors.Config{
                AllowOrigins: "*",
                AllowHeaders: "Origin, Content-Type, Accept, Authorization",
        }))
        // Si usas el validador, su configuraci√≥n ir√≠a aqu√≠.
        blacklistBankService := services.NewBlacklistBankService()
        utils.SetupValidator(blacklistBankService)

        // --- INYECCI√ìN DE DEPENDENCIAS ---

        // Servicios Fundamentales
        tokenService := auth.NewTokenService(s.AppConfig.JWTConfig)

        // Dependencias para Usuarios
        userCrudRepo := userRepo.NewUserRepository()
        userWriter := userService.NewUserWriterService(userCrudRepo, s.Connect)
        userPaginationService := pagination.NewPaginationService[models.User]()
        userPaginationRepo := userRepo.NewUserPaginationRepository(userPaginationService)
        userReader := userService.NewUserReaderService(userCrudRepo, userPaginationRepo, s.Connect)
        userHandler := handlers.NewUserHandler(userWriter, userReader)

        // Dependencias para Bancos
        bankCrudRepo := bankRepo.NewBankRepository()
        bankWriter := bankService.NewBankWriterService(bankCrudRepo, s.Connect)
        bankPaginationService := pagination.NewPaginationService[models.Bank]()
        bankPaginationRepo := bankRepo.NewBankPaginationRepository(bankPaginationService)
        bankReader := bankService.NewBankReaderService(bankCrudRepo, bankPaginationRepo, s.Connect)
        bankHandler := handlers.NewBankHandler(bankWriter, bankReader)

        // Dependencias para Autenticaci√≥n
        // CAMBIO: Se instancia el repositorio desde su nuevo paquete.
        rtRepo := refreshTokenRepo.NewRefreshTokenRepository()
        authSvc := authService.NewAuthService(userCrudRepo, rtRepo, tokenService, s.Connect)
        authHandler := handlers.NewAuthHandler(authSvc)

        // Dependencias para el Health Check de la Base de Datos
        dbService := services.NewDatabaseService(s.AppConfig, s.Connect)
        dbHandler := handlers.NewDatabaseHandler(dbService)

        // Middleware de Autenticaci√≥n
        authMiddleware := middleware.AuthMiddleware(tokenService)

        // --- REGISTRO DE RUTAS ---

        s.App.Get("/", s.HelloWorldHandler)
        api := s.App.Group("/api/v1")

        // Rutas P√∫blicas
        routes.RegisterAuthRoutes(api, authHandler)
        routes.RegisterDatabaseRoutes(api, dbHandler)

        // Rutas Protegidas (requieren token)
        protected := api.Group("/", authMiddleware)
        protected.Post("/auth/logout", authHandler.Logout)
        routes.RegisterBankRoutes(protected, bankHandler)
        routes.RegisterUserRoutes(protected, userHandler)
}</span>

// --- Handlers del Servidor ---
func (s *FiberServer) HelloWorldHandler(c *fiber.Ctx) error <span class="cov0" title="0">{
        return c.JSON(fiber.Map{
                "message": "Hello World!",
                "IP":      getLocalIP(),
        })
}</span>

func getLocalIP() string <span class="cov0" title="0">{
        addrs, err := net.InterfaceAddrs()
        if err != nil </span><span class="cov0" title="0">{
                return "unknown"
        }</span>
        <span class="cov0" title="0">for _, addr := range addrs </span><span class="cov0" title="0">{
                if ipNet, ok := addr.(*net.IPNet); ok &amp;&amp; !ipNet.IP.IsLoopback() </span><span class="cov0" title="0">{
                        if ipNet.IP.To4() != nil </span><span class="cov0" title="0">{
                                return ipNet.IP.String()
                        }</span>
                }
        }
        <span class="cov0" title="0">return "unknown"</span>
}
</pre>

		<pre class="file" id="file54" style="display: none">package server

import (
        "time"

        fiber "github.com/gofiber/fiber/v2"

        "go-fiber-core/internal/dtos/config"
        "go-fiber-core/internal/dtos/connect"
        "go-fiber-core/internal/middleware"
)

type FiberServer struct {
        *fiber.App // Incrusta la aplicaci√≥n de Fiber para heredar sus m√©todos (Use, Get, Group, etc.)
        AppConfig  config.AppConfig
        Connect    connect.ConnectDTO
}

func New(appConfig config.AppConfig, connect connect.ConnectDTO) *FiberServer <span class="cov0" title="0">{
        server := &amp;FiberServer{
                App: fiber.New(fiber.Config{
                        ServerHeader: appConfig.Server.ServerHeader,
                        AppName:      appConfig.App.AppName,
                }),
                AppConfig: appConfig,
                Connect:   connect,
        }

        // Crea la configuraci√≥n para el rate limiter (puedes leerla desde tu appConfig)
        rateLimitConfig := middleware.RateLimitConfig{
                Limit:  100,             // 100 peticiones
                Window: 1 * time.Minute, // por minuto
        }

        // Usa el middleware de rate limit pas√°ndole la conexi√≥n y la configuraci√≥n
        server.App.Use(middleware.RateLimitMiddleware(connect.ConnectRedis, rateLimitConfig))

        return server
}</span>
</pre>

		<pre class="file" id="file55" style="display: none">package auth

import (
        "context"
        "errors"
        "go-fiber-core/internal/domain"
        "go-fiber-core/internal/dtos/connect"
        "go-fiber-core/internal/dtos/requests"
        "go-fiber-core/internal/models"

        // CAMBIO: Se importa el paquete espec√≠fico para el refresh token repo.
        refreshTokenRepo "go-fiber-core/internal/repositories/refreshtoken"
        userRepo "go-fiber-core/internal/repositories/user"
        "go-fiber-core/internal/utils"
        "log"
        "strconv"
        "time"

        jwt "github.com/golang-jwt/jwt/v5"
        "gorm.io/gorm"
)

// authService es la implementaci√≥n.
type authService struct {
        userRepo userRepo.UserRepository
        // CAMBIO: El tipo de refreshTokenRepo ahora apunta al paquete importado.
        refreshTokenRepo refreshTokenRepo.RefreshTokenRepository
        tokenService     TokenService
        connect          connect.ConnectDTO
}

// NewAuthService es el constructor.
func NewAuthService(
        userRepo userRepo.UserRepository,
        // CAMBIO: El par√°metro refreshTokenRepo ahora usa el tipo correcto.
        refreshTokenRepo refreshTokenRepo.RefreshTokenRepository,
        tokenService TokenService,
        connect connect.ConnectDTO,
) AuthService <span class="cov8" title="1">{
        return &amp;authService{
                userRepo:         userRepo,
                refreshTokenRepo: refreshTokenRepo,
                tokenService:     tokenService,
                connect:          connect,
        }
}</span>

// Login realiza todas sus operaciones en la base de datos de escritura.
func (s *authService) Login(ctx context.Context, req requests.LoginRequest) (accessToken string, refreshToken string, err error) <span class="cov8" title="1">{
        db := s.connect.ConnectGormWrite

        user, err := s.userRepo.GetByEmail(ctx, db, req.Email)
        if err != nil </span><span class="cov8" title="1">{
                // CAMBIO: Devolvemos nuestro error de dominio.
                return "", "", domain.ErrAuthentication
        }</span>

        <span class="cov8" title="1">if !utils.CheckPasswordHash(req.Password, user.Password) </span><span class="cov8" title="1">{
                // CAMBIO: Devolvemos el mismo error de dominio.
                return "", "", domain.ErrAuthentication
        }</span>

        <span class="cov8" title="1">userIDStr := strconv.FormatUint(user.ID, 10)
        accessToken, refreshToken, err = s.tokenService.GenerateTokens(userIDStr)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", errors.New("error al generar tokens")
        }</span>

        <span class="cov8" title="1">if err := s.refreshTokenRepo.DeleteByUserID(ctx, db, user.ID); err != nil </span><span class="cov0" title="0">{
                log.Printf("ADVERTENCIA: No se pudo eliminar el refresh token anterior para el usuario %d: %v", user.ID, err)
        }</span>

        <span class="cov8" title="1">newRefreshToken := &amp;models.RefreshToken{
                UserID:    user.ID,
                Token:     refreshToken,
                ExpiresAt: time.Now().Add(time.Hour * 24 * 7),
        }
        if err := s.refreshTokenRepo.Create(ctx, db, newRefreshToken); err != nil </span><span class="cov0" title="0">{
                return "", "", errors.New("error al guardar la sesi√≥n")
        }</span>

        <span class="cov8" title="1">return accessToken, refreshToken, nil</span>
}

// Refresh tambi√©n realiza todas sus operaciones en la base de datos de escritura.
func (s *authService) Refresh(ctx context.Context, refreshTokenString string) (string, string, error) <span class="cov8" title="1">{
        db := s.connect.ConnectGormWrite

        token, err := s.tokenService.ValidateToken(refreshTokenString)
        if err != nil || !token.Valid </span><span class="cov8" title="1">{
                return "", "", errors.New("refresh token inv√°lido")
        }</span>

        <span class="cov8" title="1">claims, ok := token.Claims.(jwt.MapClaims)
        if !ok || claims["typ"] != "refresh" </span><span class="cov0" title="0">{
                return "", "", errors.New("token inv√°lido (no es de tipo refresh)")
        }</span>

        <span class="cov8" title="1">storedToken, err := s.refreshTokenRepo.GetByToken(ctx, db, refreshTokenString)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return "", "", errors.New("refresh token no encontrado o invalidado")
                }</span>
                <span class="cov0" title="0">return "", "", err</span>
        }

        <span class="cov8" title="1">if err := s.refreshTokenRepo.DeleteByUserID(ctx, db, storedToken.UserID); err != nil </span><span class="cov0" title="0">{
                return "", "", errors.New("error al rotar el token")
        }</span>

        <span class="cov8" title="1">userIDStr := strconv.FormatUint(storedToken.UserID, 10)
        newAccessToken, newRefreshToken, err := s.tokenService.GenerateTokens(userIDStr)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", errors.New("error al generar nuevos tokens")
        }</span>

        <span class="cov8" title="1">newRefreshTokenModel := &amp;models.RefreshToken{
                UserID:    storedToken.UserID,
                Token:     newRefreshToken,
                ExpiresAt: time.Now().Add(time.Hour * 24 * 7),
        }
        if err := s.refreshTokenRepo.Create(ctx, db, newRefreshTokenModel); err != nil </span><span class="cov0" title="0">{
                return "", "", errors.New("error al guardar la nueva sesi√≥n")
        }</span>

        <span class="cov8" title="1">return newAccessToken, newRefreshToken, nil</span>
}

// Logout es una operaci√≥n de escritura pura.
func (s *authService) Logout(ctx context.Context, userID uint64) error <span class="cov8" title="1">{
        db := s.connect.ConnectGormWrite
        return s.refreshTokenRepo.DeleteByUserID(ctx, db, userID)
}</span>
</pre>

		<pre class="file" id="file56" style="display: none">package auth

import (
        "fmt"
        "go-fiber-core/internal/dtos/config"
        "time"

        jwt "github.com/golang-jwt/jwt/v5"
)

// TokenService define la interfaz para la generaci√≥n y validaci√≥n de tokens.
type TokenService interface {
        GenerateTokens(userID string) (accessToken string, refreshToken string, err error)
        ValidateToken(tokenString string) (*jwt.Token, error)
}

type tokenService struct {
        cfg config.JWTConfig
}

// NewTokenService crea una nueva instancia de TokenService.
func NewTokenService(cfg config.JWTConfig) TokenService <span class="cov0" title="0">{
        return &amp;tokenService{cfg: cfg}
}</span>

// GenerateTokens crea un nuevo par de access y refresh tokens.
func (s *tokenService) GenerateTokens(userID string) (string, string, error) <span class="cov0" title="0">{
        // accessTTL := time.Minute * time.Duration(s.cfg.AccessTTL)
        accessTTL := time.Minute * time.Duration(s.cfg.JwtAccessTtlMinutes)
        accessToken, err := s.createToken(userID, accessTTL, s.cfg.JwtAccessSecret, "access")
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov0" title="0">refreshTTL := time.Hour * 24 * time.Duration(s.cfg.JwtRefreshTtlDays)
        refreshToken, err := s.createToken(userID, refreshTTL, s.cfg.JwtRefreshSecret, "refresh")
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov0" title="0">return accessToken, refreshToken, nil</span>
}

// createToken es un helper interno para la l√≥gica de creaci√≥n de tokens.
func (s *tokenService) createToken(userID string, ttl time.Duration, secret, tokenType string) (string, error) <span class="cov0" title="0">{
        if secret == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("el secreto JWT para '%s' no est√° configurado", tokenType)
        }</span>

        <span class="cov0" title="0">claims := jwt.MapClaims{
                "sub": userID,
                "typ": tokenType,
                "exp": time.Now().Add(ttl).Unix(),
                "iat": time.Now().Unix(),
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString([]byte(secret))</span>
}

// ValidateToken verifica la firma de un token.
func (s *tokenService) ValidateToken(tokenString string) (*jwt.Token, error) <span class="cov0" title="0">{
        parser := jwt.Parser{}
        token, _, err := parser.ParseUnverified(tokenString, jwt.MapClaims{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error al parsear el token: %w", err)
        }</span>

        <span class="cov0" title="0">claims, ok := token.Claims.(jwt.MapClaims)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("claims de token inv√°lidos")
        }</span>

        <span class="cov0" title="0">tokenType, _ := claims["typ"].(string)

        // --- L√ìGICA REFACTORIZADA ---
        // Se llama a la nueva funci√≥n privada para obtener el secreto.
        secret, err := s.getSecret(tokenType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err // Si hay error (tipo desconocido), se devuelve inmediatamente.
        }</span>

        <span class="cov0" title="0">if secret == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("el secreto JWT para '%s' no est√° configurado", tokenType)
        }</span>

        <span class="cov0" title="0">return jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("m√©todo de firma inesperado: %v", token.Header["alg"])
                }</span>
                <span class="cov0" title="0">return []byte(secret), nil</span>
        })
}

// --- NUEVA FUNCI√ìN PRIVADA ---
// getSecret determina qu√© clave secreta usar basado en el tipo de token.
func (s *tokenService) getSecret(tokenType string) (string, error) <span class="cov0" title="0">{
        if tokenType == "access" </span><span class="cov0" title="0">{
                return s.cfg.JwtAccessSecret, nil
        }</span>
        <span class="cov0" title="0">if tokenType == "refresh" </span><span class="cov0" title="0">{
                return s.cfg.JwtRefreshSecret, nil
        }</span>

        // Valor de retorno por defecto si el tipo no coincide.
        <span class="cov0" title="0">return "", fmt.Errorf("tipo de token desconocido: %s", tokenType)</span>
}
</pre>

		<pre class="file" id="file57" style="display: none">package bank

import (
        "context"
        "go-fiber-core/internal/dtos"
        "go-fiber-core/internal/dtos/connect"
        "go-fiber-core/internal/models"
        bankRepo "go-fiber-core/internal/repositories/bank"
)

// baseService contiene las dependencias comunes para los servicios de banco.
type baseService struct {
        bankRepo bankRepo.BankRepository
        connect  connect.ConnectDTO
}

// --- Implementaci√≥n para BankWriter ---

type bankWriterService struct {
        baseService // Embebe las dependencias comunes
}

// NewBankWriterService es el constructor para el servicio de escritura.
func NewBankWriterService(bankRepo bankRepo.BankRepository, connect connect.ConnectDTO) BankWriter <span class="cov8" title="1">{
        return &amp;bankWriterService{
                baseService: baseService{
                        bankRepo: bankRepo,
                        connect:  connect,
                },
        }
}</span>

func (s *bankWriterService) Create(ctx context.Context, bank *models.Bank) error <span class="cov8" title="1">{
        // Las operaciones de escritura usan la conexi√≥n de escritura.
        return s.bankRepo.Create(ctx, s.connect.ConnectGormWrite, bank)
}</span>

func (s *bankWriterService) Update(ctx context.Context, bank *models.Bank) error <span class="cov0" title="0">{
        return s.bankRepo.Update(ctx, s.connect.ConnectGormWrite, bank)
}</span>

func (s *bankWriterService) SoftDelete(ctx context.Context, id uint) error <span class="cov0" title="0">{
        return s.bankRepo.SoftDelete(ctx, s.connect.ConnectGormWrite, id)
}</span>

func (s *bankWriterService) HardDelete(ctx context.Context, id uint) error <span class="cov0" title="0">{
        return s.bankRepo.HardDelete(ctx, s.connect.ConnectGormWrite, id)
}</span>

// --- Implementaci√≥n para BankReader ---

type bankReaderService struct {
        baseService    // Embebe las dependencias comunes
        paginationRepo bankRepo.BankPaginationRepository
}

// NewBankReaderService es el constructor para el servicio de lectura.
func NewBankReaderService(bankRepo bankRepo.BankRepository, paginationRepo bankRepo.BankPaginationRepository, connect connect.ConnectDTO) BankReader <span class="cov8" title="1">{
        return &amp;bankReaderService{
                baseService: baseService{
                        bankRepo: bankRepo,
                        connect:  connect,
                },
                paginationRepo: paginationRepo,
        }
}</span>

func (s *bankReaderService) GetAll(ctx context.Context) ([]models.Bank, error) <span class="cov0" title="0">{
        // Las operaciones de lectura usan la conexi√≥n de lectura.
        return s.bankRepo.GetAll(ctx, s.connect.ConnectGormRead)
}</span>

func (s *bankReaderService) GetByID(ctx context.Context, id uint) (*models.Bank, error) <span class="cov8" title="1">{
        return s.bankRepo.GetByID(ctx, s.connect.ConnectGormRead, id)
}</span>

func (s *bankReaderService) GetAllPaginated(ctx context.Context, req dtos.PaginationRequest) (*dtos.PaginationResponse[models.Bank], error) <span class="cov8" title="1">{
        return s.paginationRepo.GetAllPaginated(ctx, s.connect.ConnectGormRead, req)
}</span>

func (s *bankReaderService) GetAllPaginatedWithRelations(ctx context.Context, req dtos.PaginationRequest) (*dtos.PaginationResponse[models.Bank], error) <span class="cov0" title="0">{
        return s.paginationRepo.GetAllPaginatedWithRelations(ctx, s.connect.ConnectGormRead, req)
}</span>
</pre>

		<pre class="file" id="file58" style="display: none">package services

// Para este ejemplo, la lista negra est√° definida en el c√≥digo.
// En una aplicaci√≥n real, esto podr√≠a venir de la base de datos o de un archivo de configuraci√≥n.
var blacklistedBankCodes = map[string]bool{
        "0001": true,
        "0003": true,
        "0005": true,
}

// IBlacklistBankService define la interfaz para nuestro servicio.
type IBlacklistBankService interface {
        IsEntityCodeBlacklisted(entityCode string) bool
}

// NewBlacklistBankService crea una nueva instancia del servicio.
func NewBlacklistBankService() IBlacklistBankService <span class="cov0" title="0">{
        return &amp;blacklistBankService{}
}</span>

// blacklistBankService es la implementaci√≥n concreta de la interfaz.
type blacklistBankService struct{}

// IsEntityCodeBlacklisted verifica si un c√≥digo de entidad est√° en la lista negra.
func (s *blacklistBankService) IsEntityCodeBlacklisted(entityCode string) bool <span class="cov0" title="0">{
        // Usar un mapa para la b√∫squeda es m√°s eficiente que recorrer un slice.
        _, exists := blacklistedBankCodes[entityCode]
        return exists
}</span>
</pre>

		<pre class="file" id="file59" style="display: none">package services

import (
        "context"
        "fmt"
        "go-fiber-core/internal/dtos/config"
        "go-fiber-core/internal/dtos/connect"
        "time"

        "github.com/jackc/pgx/v5/pgxpool"
        "gorm.io/gorm"
)

// DatabaseService no necesita cambios en su estructura.
type DatabaseService struct {
        AppConfig config.AppConfig
        Db        connect.ConnectDTO
}

// NewDatabaseService no necesita cambios.
func NewDatabaseService(appConfig config.AppConfig, connect connect.ConnectDTO) *DatabaseService <span class="cov0" title="0">{
        return &amp;DatabaseService{
                AppConfig: appConfig,
                Db:        connect,
        }
}</span>

// --- CHEQUEOS DE SALUD PARA GORM ---

// checkGormHealth es un helper interno para no repetir c√≥digo.
func (s *DatabaseService) checkGormHealth(db *gorm.DB, cfg config.GormConnectionConfig, connectionName string) map[string]any <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
        defer cancel()

        sqlDB, err := db.DB()
        if err != nil </span><span class="cov0" title="0">{
                return map[string]any{
                        "database":     cfg.Database,
                        "connection":   connectionName,
                        "connect_type": "gorm",
                        "status":       "Down",
                        "error":        fmt.Sprintf("failed to get underlying sql.DB: %v", err),
                }
        }</span>

        <span class="cov0" title="0">if err = sqlDB.PingContext(ctx); err != nil </span><span class="cov0" title="0">{
                return map[string]any{
                        "database":     cfg.Database,
                        "connection":   connectionName,
                        "connect_type": "gorm",
                        "status":       "Down",
                        "error":        fmt.Sprintf("db down: %v", err),
                }
        }</span>

        <span class="cov0" title="0">dbStats := sqlDB.Stats()
        return map[string]any{
                "database":            cfg.Database,
                "connection":          connectionName,
                "connect_type":        "gorm",
                "status":              "Up",
                "message":             "It's healthy",
                "open_connections":    dbStats.OpenConnections,
                "in_use":              dbStats.InUse,
                "idle":                dbStats.Idle,
                "wait_count":          dbStats.WaitCount,
                "wait_duration":       dbStats.WaitDuration.String(),
                "max_idle_closed":     dbStats.MaxIdleClosed,
                "max_lifetime_closed": dbStats.MaxLifetimeClosed,
        }</span>
}

// HealthGormWrite verifica la conexi√≥n de escritura de GORM.
func (s *DatabaseService) HealthGormWrite() map[string]any <span class="cov0" title="0">{
        return s.checkGormHealth(s.Db.ConnectGormWrite, s.AppConfig.MultiDatabaseConfig.Gorm.Write, "gorm-write")
}</span>

// HealthGormRead verifica la conexi√≥n de lectura de GORM.
func (s *DatabaseService) HealthGormRead() map[string]any <span class="cov0" title="0">{
        return s.checkGormHealth(s.Db.ConnectGormRead, s.AppConfig.MultiDatabaseConfig.Gorm.Read, "gorm-read")
}</span>

// --- CHEQUEOS DE SALUD PARA PGX ---

// checkPgxHealth es un helper interno para PGX.
func (s *DatabaseService) checkPgxHealth(pool *pgxpool.Pool, cfg config.PgxConnectionConfig, connectionName string) map[string]any <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
        defer cancel()

        if err := pool.Ping(ctx); err != nil </span><span class="cov0" title="0">{
                return map[string]any{
                        "database":     cfg.Database,
                        "connection":   connectionName,
                        "status":       "Down",
                        "connect_type": "pgx",
                        "error":        fmt.Sprintf("db down: %v", err),
                }
        }</span>

        <span class="cov0" title="0">poolStats := pool.Stat()
        return map[string]any{
                "database":           cfg.Database,
                "connection":         connectionName,
                "status":             "Up",
                "connect_type":       "pgx",
                "message":            "It's healthy",
                "total_conns":        poolStats.TotalConns(),
                "idle_conns":         poolStats.IdleConns(),
                "acquired_conns":     poolStats.AcquiredConns(),
                "constructing_conns": poolStats.ConstructingConns(),
                "max_conns":          poolStats.MaxConns(),
        }</span>
}

// HealthPgxWrite verifica la conexi√≥n de escritura de PGX.
func (s *DatabaseService) HealthPgxWrite() map[string]any <span class="cov0" title="0">{
        return s.checkPgxHealth(s.Db.ConnectPgxWrite, s.AppConfig.MultiDatabaseConfig.Pgx.Write, "pgx-write")
}</span>

// HealthPgxRead verifica la conexi√≥n de lectura de PGX.
func (s *DatabaseService) HealthPgxRead() map[string]any <span class="cov0" title="0">{
        return s.checkPgxHealth(s.Db.ConnectPgxRead, s.AppConfig.MultiDatabaseConfig.Pgx.Read, "pgx-read")
}</span>

// --- CHEQUEO DE SALUD PARA REDIS (sin cambios) ---

func (s *DatabaseService) HealthRedis() map[string]any <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
        defer cancel()

        // Usamos el host como nombre ya que Redis no tiene un "nombre de base de datos" como SQL.
        nameDatabase := s.AppConfig.Redis.RedisHost

        if err := s.Db.ConnectRedis.Ping(ctx).Err(); err != nil </span><span class="cov0" title="0">{
                return map[string]any{
                        "database":     nameDatabase,
                        "status":       "Down",
                        "connect_type": "Redis",
                        "error":        fmt.Sprintf("redis down: %v", err),
                }
        }</span>

        <span class="cov0" title="0">return map[string]any{
                "database":     nameDatabase,
                "status":       "Up",
                "connect_type": "redis",
                "message":      "It's healthy",
        }</span>
}
</pre>

		<pre class="file" id="file60" style="display: none">package email

import (
        "context"
        "fmt"

        gomail "gopkg.in/gomail.v2" // ‚úÖ Esta l√≠nea soluciona el error

        "go-fiber-core/internal/dtos/config"
)

// EmailService encapsula la configuraci√≥n y la conexi√≥n para enviar correos.
type EmailService struct {
        from   string
        dialer *gomail.Dialer // El dialer se reutiliza para mejorar el rendimiento.
}

// NewEmailService crea y configura una nueva instancia del servicio de email.
// El dialer se inicializa aqu√≠ y se mantiene durante la vida del servicio.
func NewEmailService(emailConfig config.EmailConfig) *EmailService <span class="cov0" title="0">{
        dialer := gomail.NewDialer(
                // emailConfig.SMTPHost,
                emailConfig.SmtpHost,
                emailConfig.SmtpPort,
                emailConfig.SmtpUsername,
                emailConfig.SmtpPassword,
        )
        return &amp;EmailService{
                from:   emailConfig.SmtpFrom,
                dialer: dialer,
        }
}</span>

// Send env√≠a un correo electr√≥nico.
// Acepta un contexto para controlar timeouts y cancelaciones.
// El contenido del cuerpo se espera que ya est√© en formato HTML.
func (s *EmailService) Send(ctx context.Context, to, subject, htmlContent string) error <span class="cov0" title="0">{
        msg := gomail.NewMessage()
        msg.SetHeader("From", s.from)
        msg.SetHeader("To", to)
        msg.SetHeader("Subject", subject)
        msg.SetBody("text/html", htmlContent)

        // Usamos un canal para poder seleccionar entre el resultado del env√≠o y la cancelaci√≥n del contexto.
        errChan := make(chan error, 1)
        go func() </span><span class="cov0" title="0">{
                // DialAndSend es una operaci√≥n bloqueante. La ejecutamos en una goroutine.
                errChan &lt;- s.dialer.DialAndSend(msg)
        }</span>()

        <span class="cov0" title="0">select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0"> // Si el contexto se cancela (ej. timeout, Ctrl+C).
                return ctx.Err()</span>
        case err := &lt;-errChan:<span class="cov0" title="0"> // Si el env√≠o termina (con o sin error).
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error enviando correo: %w", err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
}
</pre>

		<pre class="file" id="file61" style="display: none">package types

import (
        "bytes"
        "context"
        "fmt"
        "text/template"

        blackfriday "github.com/russross/blackfriday/v2" // ‚úÖ Esta l√≠nea soluciona el error

        "go-fiber-core/internal/services/email" // Importamos la interfaz del servicio
)

// ContactEmailData define los campos din√°micos para la plantilla del correo de contacto.
type ContactEmailData struct {
        Name string
        Edad int
}

// ContactSender se especializa en enviar un tipo espec√≠fico de email.
type ContactSender struct {
        emailService *email.EmailService
        emailTmpl    *template.Template
}

// NewContactSender crea un nuevo sender para emails de contacto.
// Recibe sus dependencias y pre-parsea la plantilla para eficiencia.
func NewContactSender(emailService *email.EmailService) (*ContactSender, error) <span class="cov0" title="0">{
        // La plantilla se define y parsea una sola vez.
        markdownContent := `
# Bienvenido a nuestro servicio, {{ .Name }}

Sabemos que usted tiene {{ .Edad }} a√±os.

Gracias por registrarte. Esperamos que disfrutes de la experiencia.

**Saludos,**
El equipo de soporte.
`
        tmpl, err := template.New("contactEmail").Parse(markdownContent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error al parsear la plantilla de email de contacto: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;ContactSender{
                emailService: emailService,
                emailTmpl:    tmpl,
        }, nil</span>
}

// Send ejecuta la l√≥gica para enviar el correo de contacto.
func (s *ContactSender) Send(ctx context.Context, to, subject string, data ContactEmailData) error <span class="cov0" title="0">{
        var body bytes.Buffer
        // Renderiza la plantilla con los datos espec√≠ficos de esta llamada.
        if err := s.emailTmpl.Execute(&amp;body, data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error ejecutando la plantilla: %w", err)
        }</span>

        // Convierte el resultado de Markdown a HTML.
        <span class="cov0" title="0">htmlContent := blackfriday.Run(body.Bytes())

        // Llama al servicio base para realizar el env√≠o.
        return s.emailService.Send(ctx, to, subject, string(htmlContent))</span>
}
</pre>

		<pre class="file" id="file62" style="display: none">package loanrisk

import (
        "fmt"
        "go-fiber-core/internal/services/serviceconfig/contracts"
)

type Age struct {
        params      map[string]any
        servicePath string
}

func NewAgeService() contracts.Service <span class="cov0" title="0">{
        return &amp;Age{}
}</span>

func (a *Age) Init(params map[string]any, servicePath string) <span class="cov0" title="0">{
        a.params = params
        a.servicePath = servicePath
}</span>

func (a *Age) Execute() error <span class="cov0" title="0">{
        fmt.Println("üßÆ Ejecutando servicio Age")

        result := map[string]any{
                "age_processed": fmt.Sprintf("Edad validada: %v", a.params["age"]),
        }

        a.params["results"].(map[string]any)[a.servicePath] = result
        return nil
}</span>
</pre>

		<pre class="file" id="file63" style="display: none">// internal/services/loanrisk/isrenovation.go
package loanrisk

import (
        "fmt"
        "go-fiber-core/internal/services/serviceconfig/contracts"
)

type IsRenovation struct {
        params      map[string]any
        servicePath string
}

func NewIsRenovationService() contracts.Service <span class="cov0" title="0">{
        return &amp;IsRenovation{}
}</span>

func (a *IsRenovation) Init(params map[string]any, servicePath string) <span class="cov0" title="0">{
        a.params = params
        a.servicePath = servicePath
}</span>

func (a *IsRenovation) Execute() error <span class="cov0" title="0">{
        fmt.Println("üîÅ Ejecutando servicio IsRenovation con par√°metros")

        // if cid, ok := r.params["customer_id"]; ok {
        //         fmt.Printf("ID de cliente: %v\n", cid)
        // } else {
        //         fmt.Println("Falta 'customer_id'")
        // }

        // if isNew, ok := r.params["is_new"]; ok {
        //         fmt.Printf("¬øEs nuevo? %v\n", isNew)
        // } else {
        //         fmt.Println("Falta 'is_new'")
        // }

        fmt.Println("üßÆ Ejecutando servicio Age")

        result := map[string]any{
                "age_processed": fmt.Sprintf("Edad validada: %v", a.params["age"]),
        }

        a.params["results"].(map[string]any)[a.servicePath] = result

        return nil
}</span>
</pre>

		<pre class="file" id="file64" style="display: none">package loanrisk

import (
        "fmt"
        "go-fiber-core/internal/services/serviceconfig/contracts"
)

// Estructura del servicio Padron
type RiskLevel struct {
        params      map[string]any
        servicePath string
}

// Constructor del servicio Padron
func NewRiskLevelService() contracts.Service <span class="cov0" title="0">{
        return &amp;RiskLevel{}
}</span>

// Init permite pasar par√°metros din√°micos
func (a *RiskLevel) Init(params map[string]any, servicePath string) <span class="cov0" title="0">{
        a.params = params
        a.servicePath = servicePath
}</span>

// Implementaci√≥n de la interfaz Service
func (p *RiskLevel) Execute() error <span class="cov0" title="0">{
        fmt.Println("Ejecutando el servicio loan risk Age")

        // Us√°s los par√°metros si existen
        if ageVal, ok := p.params["age"]; ok </span><span class="cov0" title="0">{
                fmt.Printf("Par√°metro recibido 'age': %v\n", ageVal)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("No se recibi√≥ el par√°metro 'age'")
        }</span>

        <span class="cov0" title="0">result := map[string]any{
                "age_processed": fmt.Sprintf("Edad validada: %v", p.params["age"]),
        }

        p.params["results"].(map[string]any)[p.servicePath] = result
        return nil</span>
}
</pre>

		<pre class="file" id="file65" style="display: none">// internal/services/loanrisk/salary.go
package loanrisk

import (
        "fmt"
        "go-fiber-core/internal/services/serviceconfig/contracts"
)

type Salary struct {
        params      map[string]any
        servicePath string
}

func NewSalaryService() contracts.Service <span class="cov0" title="0">{
        return &amp;Salary{}
}</span>

func (s *Salary) Init(params map[string]any, servicePath string) <span class="cov0" title="0">{
        s.params = params
        s.servicePath = servicePath
}</span>

func (s *Salary) Execute() error <span class="cov0" title="0">{
        fmt.Println("üí∞ Ejecutando servicio Salary")

        result := map[string]any{
                "salary_checked": true,
        }

        s.params["results"].(map[string]any)[s.servicePath] = result
        return nil
}</span>
</pre>

		<pre class="file" id="file66" style="display: none">package pagination

import (
        "fmt"
        "go-fiber-core/internal/dtos"
        "log"
        "math"
        "reflect"
        "strings"
        "time"

        "golang.org/x/text/cases"
        "golang.org/x/text/language"

        "gorm.io/gorm"
        "gorm.io/gorm/schema"
)

// QueryModifier es un tipo de funci√≥n para aplicar modificaciones personalizadas a la consulta.
type QueryModifier func(*gorm.DB) *gorm.DB

// ExtrasCalculator es un tipo de funci√≥n para calcular datos adicionales a partir de la consulta.
type ExtrasCalculator func(query *gorm.DB) (map[string]any, error)

// PaginationService es ahora una struct gen√©rica.
type PaginationService[T any] struct{}

// NewPaginationService es el constructor gen√©rico.
func NewPaginationService[T any]() *PaginationService[T] <span class="cov8" title="1">{
        return &amp;PaginationService[T]{}
}</span>

// Execute es el m√©todo gen√©rico principal para paginar resultados.
func (p *PaginationService[T]) Execute(db *gorm.DB, req dtos.PaginationRequest, modifier QueryModifier, extrasCalc ExtrasCalculator) (*dtos.PaginationResponse[T], error) <span class="cov8" title="1">{
        var totalRows int64
        var extras map[string]any
        var modelInstance T
        dateColumns := p.GetDateColumnsFromModel(modelInstance)

        query := db.Model(new(T))

        if modifier != nil </span><span class="cov8" title="1">{
                query = modifier(query)
        }</span>

        <span class="cov8" title="1">query = p.ApplyFilters(query, req, dateColumns)

        if extrasCalc != nil </span><span class="cov8" title="1">{
                var err error
                extrasQuery := query.Session(&amp;gorm.Session{})
                extras, err = extrasCalc(extrasQuery)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">countQuery := query.Session(&amp;gorm.Session{})
        if err := countQuery.Count(&amp;totalRows).Error; err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">totalPages := 0
        if totalRows &gt; 0 &amp;&amp; req.RowsPerPage &gt; 0 </span><span class="cov8" title="1">{
                totalPages = int(math.Ceil(float64(totalRows) / float64(req.RowsPerPage)))
        }</span>
        <span class="cov8" title="1">if req.Page &gt; totalPages &amp;&amp; totalPages &gt; 0 </span><span class="cov0" title="0">{
                req.Page = totalPages
        }</span>

        <span class="cov8" title="1">if totalRows == 0 </span><span class="cov8" title="1">{
                return &amp;dtos.PaginationResponse[T]{Data: []T{}, TotalRows: 0, TotalPages: 0, Page: 1, RowsPerPage: req.RowsPerPage, Extras: extras}, nil
        }</span>

        <span class="cov8" title="1">const deferredJoinThreshold = 10
        if req.OptimizeWithKey != "" &amp;&amp; req.Page &gt; deferredJoinThreshold </span><span class="cov8" title="1">{
                query = p.applyDeferredJoinPagination(db, query, req, modelInstance)
        }</span> else<span class="cov8" title="1"> {
                query = p.applyStandardPagination(query, req)
        }</span>

        <span class="cov8" title="1">var data []T
        if err := query.Find(&amp;data).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;dtos.PaginationResponse[T]{Data: data, TotalRows: totalRows, TotalPages: totalPages, Page: req.Page, RowsPerPage: req.RowsPerPage, Extras: extras}, nil</span>
}

// ApplyFilters aplica los filtros de la solicitud a la consulta de GORM.
func (p *PaginationService[T]) ApplyFilters(db *gorm.DB, req dtos.PaginationRequest, dateColumns map[string]bool) *gorm.DB <span class="cov8" title="1">{
        if len(req.FilterBy) == 0 </span><span class="cov8" title="1">{
                return db
        }</span>
        <span class="cov8" title="1">namingStrategy := schema.NamingStrategy{}
        caser := cases.Title(language.English)
        for i, filterBy := range req.FilterBy </span><span class="cov8" title="1">{
                if i &gt;= len(req.FilterValues) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">filterValue := req.FilterValues[i]

                if strings.Contains(filterBy, "::") </span><span class="cov8" title="1">{
                        parts := strings.SplitN(filterBy, "::", 2)
                        db = db.Where(parts[0]+"."+parts[1]+" = ?", filterValue)
                        continue</span>
                }

                <span class="cov8" title="1">if strings.Contains(filterBy, ".") &amp;&amp; !strings.HasSuffix(filterBy, ":fuzzy") </span><span class="cov8" title="1">{
                        lastDotIndex := strings.LastIndex(filterBy, ".")
                        joinPath, finalFieldName := filterBy[:lastDotIndex], filterBy[lastDotIndex+1:]
                        relations := strings.Split(joinPath, ".")
                        gormJoinPath := ""
                        for i, rel := range relations </span><span class="cov8" title="1">{
                                gormJoinPath += caser.String(rel)
                                if i &lt; len(relations)-1 </span><span class="cov0" title="0">{
                                        gormJoinPath += "."
                                }</span>
                        }
                        <span class="cov8" title="1">db = db.Joins(gormJoinPath)
                        finalRelationName := relations[len(relations)-1]
                        finalTableName := namingStrategy.TableName(caser.String(finalRelationName))
                        db = db.Where(finalTableName+"."+finalFieldName+" = ?", filterValue)
                        continue</span>
                }
                <span class="cov8" title="1">if _, isDate := dateColumns[filterBy]; isDate </span><span class="cov8" title="1">{
                        if values, ok := filterValue.([]any); ok &amp;&amp; len(values) == 2 </span><span class="cov8" title="1">{
                                startStr, ok1 := values[0].(string)
                                endStr, ok2 := values[1].(string)
                                if ok1 &amp;&amp; ok2 </span><span class="cov8" title="1">{
                                        start, err1 := time.Parse("2006-01-02", startStr)
                                        end, err2 := time.Parse("2006-01-02", endStr)
                                        if err1 == nil &amp;&amp; err2 == nil </span><span class="cov8" title="1">{
                                                endOfDay := end.Add(24 * time.Hour)
                                                db = db.Where(filterBy+" &gt;= ? AND "+filterBy+" &lt; ?", start, endOfDay)
                                                continue</span>
                                        }
                                }
                        }
                }
                <span class="cov8" title="1">if strings.HasSuffix(filterBy, ":fuzzy") </span><span class="cov8" title="1">{
                        columnName := strings.TrimSuffix(filterBy, ":fuzzy")
                        if db.Name() == "postgres" </span><span class="cov8" title="1">{
                                db = db.Where(columnName+" % ?", filterValue)
                        }</span> else<span class="cov0" title="0"> {
                                if str, ok := filterValue.(string); ok </span><span class="cov0" title="0">{
                                        db = db.Where("LOWER("+columnName+") LIKE LOWER(?)", "%"+str+"%")
                                }</span>
                        }
                        <span class="cov8" title="1">continue</span>
                }
                <span class="cov8" title="1">if str, ok := filterValue.(string); ok &amp;&amp; p.isLike(str) </span><span class="cov8" title="1">{
                        if db.Name() == "postgres" </span><span class="cov8" title="1">{
                                db = db.Where(filterBy+" ILIKE ?", str)
                        }</span> else<span class="cov0" title="0"> {
                                db = db.Where("LOWER("+filterBy+") LIKE LOWER(?)", str)
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }
                <span class="cov8" title="1">if values, ok := filterValue.([]any); ok </span><span class="cov8" title="1">{
                        db = db.Where(filterBy+" IN ?", values)
                        continue</span>
                }
                <span class="cov8" title="1">if val, ok := filterValue.(bool); ok </span><span class="cov0" title="0">{
                        db = db.Where(filterBy+" = ?", val)
                        continue</span>
                }
                <span class="cov8" title="1">if filterValue != nil </span><span class="cov8" title="1">{
                        db = db.Where("LOWER("+filterBy+") = LOWER(?)", filterValue)
                }</span>
        }
        <span class="cov8" title="1">return db</span>
}

// GetDateColumnsFromModel extrae las columnas de fecha a partir de los tags del modelo.
func (p *PaginationService[T]) GetDateColumnsFromModel(model any) map[string]bool <span class="cov8" title="1">{
        dateColumns := make(map[string]bool)
        modelType := reflect.Indirect(reflect.ValueOf(model)).Type()
        namingStrategy := schema.NamingStrategy{}
        for i := 0; i &lt; modelType.NumField(); i++ </span><span class="cov8" title="1">{
                field := modelType.Field(i)
                if tag, ok := field.Tag.Lookup("filter"); ok &amp;&amp; tag == "date" </span><span class="cov8" title="1">{
                        columnName := namingStrategy.ColumnName("", field.Name)
                        dateColumns[columnName] = true
                }</span>
        }
        <span class="cov8" title="1">return dateColumns</span>
}

// ApplyOrder aplica el ordenamiento a la consulta.
func (p *PaginationService[T]) ApplyOrder(db *gorm.DB, req dtos.PaginationRequest) *gorm.DB <span class="cov8" title="1">{
        if len(req.SortBy) &gt; 0 </span><span class="cov8" title="1">{
                namingStrategy := schema.NamingStrategy{}
                caser := cases.Title(language.English)
                for i, sortBy := range req.SortBy </span><span class="cov8" title="1">{
                        order := "ASC"
                        if i &lt; len(req.SortDesc) &amp;&amp; req.SortDesc[i] </span><span class="cov8" title="1">{
                                order = "DESC"
                        }</span>

                        <span class="cov8" title="1">if strings.Contains(sortBy, "::") </span><span class="cov8" title="1">{
                                db = db.Order(strings.Replace(sortBy, "::", ".", 1) + " " + order)
                                continue</span>
                        }

                        <span class="cov8" title="1">if strings.HasSuffix(sortBy, ":fuzzy") </span><span class="cov0" title="0">{
                                columnName := strings.TrimSuffix(sortBy, ":fuzzy")
                                if db.Name() == "postgres" </span><span class="cov0" title="0">{
                                        var matchingValue any
                                        for j, filterBy := range req.FilterBy </span><span class="cov0" title="0">{
                                                if filterBy == sortBy </span><span class="cov0" title="0">{
                                                        if j &lt; len(req.FilterValues) </span><span class="cov0" title="0">{
                                                                matchingValue = req.FilterValues[j]
                                                                break</span>
                                                        }
                                                }
                                        }
                                        <span class="cov0" title="0">if matchingValue != nil </span><span class="cov0" title="0">{
                                                db = db.Order(gorm.Expr(columnName+" &lt;-&gt; ? "+order, matchingValue))
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        db = db.Order(columnName + " " + order)
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }
                        <span class="cov8" title="1">if strings.Contains(sortBy, ".") </span><span class="cov8" title="1">{
                                lastDotIndex := strings.LastIndex(sortBy, ".")
                                joinPath, finalFieldName := sortBy[:lastDotIndex], sortBy[lastDotIndex+1:]
                                relations := strings.Split(joinPath, ".")
                                gormJoinPath := ""
                                for i, rel := range relations </span><span class="cov8" title="1">{
                                        gormJoinPath += caser.String(rel)
                                        if i &lt; len(relations)-1 </span><span class="cov0" title="0">{
                                                gormJoinPath += "."
                                        }</span>
                                }
                                <span class="cov8" title="1">db = db.Joins(gormJoinPath)
                                finalRelationName := relations[len(relations)-1]
                                finalTableName := namingStrategy.TableName(caser.String(finalRelationName))
                                db = db.Order(finalTableName + "." + finalFieldName + " " + order)</span>
                        } else<span class="cov8" title="1"> {
                                db = db.Order(sortBy + " " + order)
                        }</span>
                }
        }
        <span class="cov8" title="1">return db</span>
}

// applyLimitOffset es una funci√≥n helper interna.
func (p *PaginationService[T]) applyLimitOffset(db *gorm.DB, req dtos.PaginationRequest) *gorm.DB <span class="cov8" title="1">{
        if req.Page &gt; 0 &amp;&amp; req.RowsPerPage &gt; 0 </span><span class="cov8" title="1">{
                offset := (req.Page - 1) * req.RowsPerPage
                db = db.Limit(req.RowsPerPage).Offset(offset)
        }</span>
        <span class="cov8" title="1">return db</span>
}

// applyStandardPagination aplica orden, l√≠mite y offset.
func (p *PaginationService[T]) applyStandardPagination(db *gorm.DB, req dtos.PaginationRequest) *gorm.DB <span class="cov8" title="1">{
        if len(req.SortBy) == 0 </span><span class="cov8" title="1">{
                var model T
                stmt := &amp;gorm.Statement{DB: db}
                if err := stmt.Parse(model); err == nil &amp;&amp; stmt.Schema != nil &amp;&amp; stmt.Schema.PrioritizedPrimaryField != nil </span><span class="cov8" title="1">{
                        primaryKey := stmt.Schema.PrioritizedPrimaryField.DBName
                        db = db.Order(fmt.Sprintf(`"%s"."%s" ASC`, stmt.Schema.Table, primaryKey))
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("Advertencia: No se pudo determinar la clave primaria para el ordenamiento por defecto del modelo %T", model)
                }</span>
        } else<span class="cov8" title="1"> {
                db = p.ApplyOrder(db, req)
        }</span>
        <span class="cov8" title="1">return p.applyLimitOffset(db, req)</span>
}

// applyDeferredJoinPagination optimiza la paginaci√≥n buscando primero los IDs.
func (p *PaginationService[T]) applyDeferredJoinPagination(db *gorm.DB, query *gorm.DB, req dtos.PaginationRequest, model any) *gorm.DB <span class="cov8" title="1">{
        tableName := query.Statement.Table
        if tableName == "" </span><span class="cov8" title="1">{
                stmt := &amp;gorm.Statement{DB: query}
                if err := stmt.Parse(model); err != nil </span><span class="cov0" title="0">{
                        log.Printf("ERROR: Fall√≥ el parseo del modelo en paginaci√≥n diferida: %v", err)
                        return query.Where("1 = 0")
                }</span>
                <span class="cov8" title="1">tableName = stmt.Schema.Table</span>
        }
        <span class="cov8" title="1">var pageIDs []uint
        idQuery := query.Session(&amp;gorm.Session{}).Select(req.OptimizeWithKey)
        idQuery = p.applyStandardPagination(idQuery, req)
        idQuery.Find(&amp;pageIDs)
        if len(pageIDs) == 0 </span><span class="cov0" title="0">{
                return query.Where("1 = 0")
        }</span>

        <span class="cov8" title="1">whereCondition := fmt.Sprintf(`"%s"."%s" IN (?)`, tableName, req.OptimizeWithKey)
        finalQuery := db.Model(model).Where(whereCondition, pageIDs)

        if len(req.SortBy) == 0 </span><span class="cov8" title="1">{
                var m T
                stmt := &amp;gorm.Statement{DB: db}
                if err := stmt.Parse(m); err == nil &amp;&amp; stmt.Schema != nil &amp;&amp; stmt.Schema.PrioritizedPrimaryField != nil </span><span class="cov8" title="1">{
                        primaryKey := stmt.Schema.PrioritizedPrimaryField.DBName
                        finalQuery = finalQuery.Order(fmt.Sprintf(`"%s"."%s" ASC`, stmt.Schema.Table, primaryKey))
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("Advertencia: No se pudo determinar la clave primaria para el ordenamiento por defecto del modelo %T", m)
                }</span>
        } else<span class="cov0" title="0"> {
                finalQuery = p.ApplyOrder(finalQuery, req)
        }</span>

        <span class="cov8" title="1">return finalQuery</span>
}

// isLike verifica si un valor es para una b√∫squeda con LIKE.
func (p *PaginationService[T]) isLike(value string) bool <span class="cov8" title="1">{
        return len(value) &gt; 2 &amp;&amp; strings.HasPrefix(value, "%") &amp;&amp; strings.HasSuffix(value, "%")
}</span>
</pre>

		<pre class="file" id="file67" style="display: none">package serviceconfig

import (
        "fmt"
)

func ExecuteService(name string, params *map[string]any) error <span class="cov0" title="0">{
        constructor, exists := ServiceConstructors[name]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("servicio no encontrado: %s", name)
        }</span>

        // Inicializar si no existe
        <span class="cov0" title="0">if _, ok := (*params)["steps"]; !ok </span><span class="cov0" title="0">{
                (*params)["steps"] = []string{}
        }</span>
        <span class="cov0" title="0">if _, ok := (*params)["results"]; !ok </span><span class="cov0" title="0">{
                (*params)["results"] = map[string]any{}
        }</span>

        <span class="cov0" title="0">service := constructor()
        service.Init(*params, name)

        // Agregar paso al historial
        (*params)["steps"] = append((*params)["steps"].([]string), name)

        return service.Execute()</span>
}

// Ejecutar m√∫ltiples servicios en orden
func ExecuteServicesInOrder(services []ServiceRegistryRow, params map[string]any) (map[string]any, error) <span class="cov0" title="0">{
        // Inicializar claves necesarias
        if _, ok := params["steps"]; !ok </span><span class="cov0" title="0">{
                params["steps"] = []string{}
        }</span>
        <span class="cov0" title="0">if _, ok := params["results"]; !ok </span><span class="cov0" title="0">{
                params["results"] = map[string]any{}
        }</span>

        <span class="cov0" title="0">for _, serviceInfo := range services </span><span class="cov0" title="0">{
                constructor, exists := ServiceConstructors[serviceInfo.Path]
                if !exists </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("servicio no encontrado: %s", serviceInfo.Path)
                }</span>

                <span class="cov0" title="0">service := constructor()
                service.Init(params, serviceInfo.Path)

                // Agregar paso al historial
                params["steps"] = append(params["steps"].([]string), serviceInfo.Path)

                if err := service.Execute(); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error ejecutando %s: %w", serviceInfo.Path, err)
                }</span>
        }

        <span class="cov0" title="0">return params, nil</span>
}
</pre>

		<pre class="file" id="file68" style="display: none">package user

import (
        "context"
        "go-fiber-core/internal/dtos"
        "go-fiber-core/internal/dtos/connect"
        "go-fiber-core/internal/models"
        userRepo "go-fiber-core/internal/repositories/user"

        "golang.org/x/crypto/bcrypt"
)

// baseService contiene las dependencias comunes. Su estructura no cambia.
type baseService struct {
        userRepo userRepo.UserRepository
        connect  connect.ConnectDTO
}

// --- Implementaci√≥n para UserWriter ---

type userWriterService struct {
        baseService // Embebe las dependencias comunes
}

// NewUserWriterService no necesita cambios en su firma.
func NewUserWriterService(userRepo userRepo.UserRepository, connect connect.ConnectDTO) UserWriter <span class="cov8" title="1">{
        return &amp;userWriterService{
                baseService: baseService{
                        userRepo: userRepo,
                        connect:  connect,
                },
        }
}</span>

func (s *userWriterService) Create(ctx context.Context, user *models.User) error <span class="cov8" title="1">{
        hashedPassword, err := bcrypt.GenerateFromPassword([]byte(user.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">user.Password = string(hashedPassword)
        user.IsActive = true
        // CAMBIO: Se utiliza la conexi√≥n de escritura.
        return s.userRepo.Create(ctx, s.connect.ConnectGormWrite, user)</span>
}

func (s *userWriterService) Update(ctx context.Context, user *models.User) error <span class="cov8" title="1">{
        if user.Password != "" </span><span class="cov8" title="1">{
                hashedPassword, err := bcrypt.GenerateFromPassword([]byte(user.Password), bcrypt.DefaultCost)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">user.Password = string(hashedPassword)</span>
        }
        // CAMBIO: Se utiliza la conexi√≥n de escritura.
        <span class="cov8" title="1">return s.userRepo.Update(ctx, s.connect.ConnectGormWrite, user)</span>
}

func (s *userWriterService) Delete(ctx context.Context, id uint64) error <span class="cov0" title="0">{
        // CAMBIO: Se utiliza la conexi√≥n de escritura.
        return s.userRepo.SoftDelete(ctx, s.connect.ConnectGormWrite, id)
}</span>

// --- Implementaci√≥n para UserReader ---

type userReaderService struct {
        baseService
        paginationRepo userRepo.UserPaginationRepository
}

// NewUserReaderService no necesita cambios en su firma.
func NewUserReaderService(userRepo userRepo.UserRepository, paginationRepo userRepo.UserPaginationRepository, connect connect.ConnectDTO) UserReader <span class="cov8" title="1">{
        return &amp;userReaderService{
                baseService: baseService{
                        userRepo: userRepo,
                        connect:  connect,
                },
                paginationRepo: paginationRepo,
        }
}</span>

func (s *userReaderService) GetByID(ctx context.Context, id uint64) (*models.User, error) <span class="cov8" title="1">{
        // CAMBIO: Se utiliza la conexi√≥n de lectura.
        return s.userRepo.GetByID(ctx, s.connect.ConnectGormRead, id)
}</span>

func (s *userReaderService) GetAll(ctx context.Context) ([]models.User, error) <span class="cov0" title="0">{
        // CAMBIO: Se utiliza la conexi√≥n de lectura.
        return s.userRepo.GetAll(ctx, s.connect.ConnectGormRead)
}</span>

func (s *userReaderService) GetAllPaginated(ctx context.Context, req dtos.PaginationRequest) (*dtos.PaginationResponse[models.User], error) <span class="cov8" title="1">{
        // CAMBIO: Se utiliza la conexi√≥n de lectura.
        return s.paginationRepo.GetAllPaginated(ctx, s.connect.ConnectGormRead, req)
}</span>
</pre>

		<pre class="file" id="file69" style="display: none">package utils

import (
        "encoding/json"
)

func ConvertJsonNumberToInt(n json.Number) int <span class="cov0" title="0">{
        v, err := n.Int64()
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return int(v)</span>
}
</pre>

		<pre class="file" id="file70" style="display: none">package utils

import (
        "encoding/json"
)

func ConvertMapToDTO(mapa map[string]any, result any) error <span class="cov0" title="0">{
        data, err := json.Marshal(mapa)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(data, result)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>

		<pre class="file" id="file71" style="display: none">package utils

import (
        "go-fiber-core/internal/dtos/config"
)

const (
        LocalEnvValue       = "local"
        StagingEnvValue     = "staging"
        LocalDatabaseHost   = "localhost"  // Host de la DB en entorno local
        StagingDatabaseHost = "staging-db" // Host de la DB en entorno de staging
)

// IsProduction verifica si la aplicaci√≥n se est√° ejecutando en un entorno de producci√≥n.
// Retorna true si el entorno es de producci√≥n, false en caso contrario.
func IsProduction(appConfig config.AppConfig) bool <span class="cov0" title="0">{
        nonProductionEnvironments := []string{LocalEnvValue, StagingEnvValue, "development"}
        currentEnv := appConfig.App.AppEnv

        // CAMBIO: Apuntamos al host de la base de datos de escritura de GORM
        // como la fuente de verdad para determinar el entorno de la base de datos.
        dbHost := appConfig.MultiDatabaseConfig.Gorm.Write.Host

        isNonProductionEnv := false
        for _, env := range nonProductionEnvironments </span><span class="cov0" title="0">{
                if currentEnv == env </span><span class="cov0" title="0">{
                        isNonProductionEnv = true
                        break</span>
                }
        }

        <span class="cov0" title="0">isNonProductionDB := (dbHost == LocalDatabaseHost || dbHost == StagingDatabaseHost)

        // Es producci√≥n si no es un entorno de no-producci√≥n Y la DB no es de no-producci√≥n.
        return !isNonProductionEnv &amp;&amp; !isNonProductionDB</span>
}

// IsLocal verifica si la aplicaci√≥n se est√° ejecutando en un entorno local.
// Retorna true si el entorno es local, false en caso contrario.
func IsLocal(appConfig config.AppConfig) bool <span class="cov0" title="0">{
        currentEnv := appConfig.App.AppEnv

        // CAMBIO: Apuntamos al host de la base de datos de escritura de GORM.
        dbHost := appConfig.MultiDatabaseConfig.Gorm.Write.Host

        return currentEnv == LocalEnvValue &amp;&amp; dbHost == LocalDatabaseHost
}</span>
</pre>

		<pre class="file" id="file72" style="display: none">package utils

import (
        "reflect"
)

// MatchStructs copia los valores de los campos coincidentes entre dos structs
func MatchStructs(src, dest any) <span class="cov0" title="0">{
        srcVal := reflect.ValueOf(src)
        destVal := reflect.ValueOf(dest)

        // Verificamos que ambos sean punteros a structs
        if srcVal.Kind() != reflect.Ptr || destVal.Kind() != reflect.Ptr </span><span class="cov0" title="0">{
                panic("Ambos par√°metros deben ser punteros a structs")</span>
        }

        <span class="cov0" title="0">srcVal = srcVal.Elem()
        destVal = destVal.Elem()

        // Iteramos sobre los campos del struct destino
        for i := 0; i &lt; destVal.NumField(); i++ </span><span class="cov0" title="0">{
                fieldDest := destVal.Type().Field(i) // Informaci√≥n del campo
                fieldSrc := srcVal.FieldByName(fieldDest.Name)

                // Verificamos si el campo existe en el struct fuente y tienen el mismo tipo
                if fieldSrc.IsValid() &amp;&amp; fieldSrc.Type() == fieldDest.Type </span><span class="cov0" title="0">{
                        // Seteamos el valor del campo en el struct destino
                        destVal.Field(i).Set(fieldSrc)
                }</span>
        }
}
</pre>

		<pre class="file" id="file73" style="display: none">package utils

import "golang.org/x/crypto/bcrypt"

// HashPassword crea un hash bcrypt de la contrase√±a.
func HashPassword(password string) (string, error) <span class="cov0" title="0">{
        bytes, err := bcrypt.GenerateFromPassword([]byte(password), 14)
        return string(bytes), err
}</span>

// CheckPasswordHash compara una contrase√±a en texto plano con su hash.
func CheckPasswordHash(password, hash string) bool <span class="cov0" title="0">{
        err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
        return err == nil
}</span>
</pre>

		<pre class="file" id="file74" style="display: none">package utils

import (
        "errors"

        "gorm.io/gorm"
)

// GetRandomID recibe un modelo y devuelve un ID aleatorio existente en la tabla.
// Si no hay registros o hay un error, retorna 1.
func GetRandomID(db *gorm.DB, model any) int <span class="cov0" title="0">{
        // Obtenemos el nombre de la tabla del modelo usando reflexi√≥n
        stmt := &amp;gorm.Statement{DB: db}
        if err := stmt.Parse(model); err != nil </span><span class="cov0" title="0">{
                // Si no se puede parsear el modelo, retornamos 1
                return 1
        }</span>
        <span class="cov0" title="0">tableName := stmt.Schema.Table

        // Consulta SQL para obtener un ID aleatorio
        var randomID int
        query := db.Table(tableName).Select("id").Order("RANDOM()").Limit(1).Scan(&amp;randomID)

        // Manejamos los posibles errores
        if query.Error != nil </span><span class="cov0" title="0">{
                if errors.Is(query.Error, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        // Si no se encontraron registros, retornamos 1
                        return 1
                }</span>
                // Si hay otro tipo de error, tambi√©n retornamos 1
                <span class="cov0" title="0">return 1</span>
        }

        // Si se obtuvo un ID aleatorio, lo retornamos
        <span class="cov0" title="0">if randomID &gt; 0 </span><span class="cov0" title="0">{
                return randomID
        }</span>

        // En caso de que algo falle inesperadamente, retornamos 1
        <span class="cov0" title="0">return 1</span>
}
</pre>

		<pre class="file" id="file75" style="display: none">package utils

import (
        "fmt"
        "reflect"
        "strings"

        "github.com/go-playground/locales/es"
        ut "github.com/go-playground/universal-translator"
        "github.com/go-playground/validator/v10"
        es_translations "github.com/go-playground/validator/v10/translations/es"
        "github.com/gofiber/fiber/v2"
)

// BlacklistChecker define el contrato para chequear listas negras.
// Esto permite la inyecci√≥n de dependencias y desacopla el validador.
type BlacklistChecker interface {
        IsEntityCodeBlacklisted(code string) bool
}

var (
        validate *validator.Validate
        trans    ut.Translator
)

func init() <span class="cov0" title="0">{
        validate = validator.New()
}</span>

// SetupValidator inicializa el validador con sus dependencias y traducciones.
// Debe ser llamado una vez al arrancar la aplicaci√≥n.
func SetupValidator(blacklistService BlacklistChecker) <span class="cov0" title="0">{
        validate = validator.New()

        // Le ense√±amos al validador a usar los nombres de las etiquetas 'json' en los errores.
        validate.RegisterTagNameFunc(func(fld reflect.StructField) string </span><span class="cov0" title="0">{
                name := strings.SplitN(fld.Tag.Get("json"), ",", 2)[0]
                if name == "-" </span><span class="cov0" title="0">{
                        return ""
                }</span>
                <span class="cov0" title="0">return name</span>
        })

        // Configuramos el traductor a espa√±ol.
        <span class="cov0" title="0">esLocale := es.New()
        uni := ut.New(esLocale, esLocale)
        trans, _ = uni.GetTranslator("es")

        // Registramos las traducciones por defecto en espa√±ol (para 'required', 'email', etc.).
        if err := es_translations.RegisterDefaultTranslations(validate, trans); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("failed to register default translations: %v", err))</span>
        }

        // Registramos nuestras reglas y mensajes personalizados.
        <span class="cov0" title="0">registerCustomValidations(blacklistService)
        registerCustomMessages()</span>
}

// registerCustomValidations registra las reglas de validaci√≥n personalizadas.
func registerCustomValidations(blacklistService BlacklistChecker) <span class="cov0" title="0">{
        if err := validate.RegisterValidation("not_in_bank_blacklist", func(fl validator.FieldLevel) bool </span><span class="cov0" title="0">{
                return !blacklistService.IsEntityCodeBlacklisted(fl.Field().String())
        }</span>); err != nil <span class="cov0" title="0">{
                panic(fmt.Sprintf("failed to register custom validation: %v", err))</span>
        }
}

// registerCustomMessages registra los mensajes de error personalizados en espa√±ol.
func registerCustomMessages() <span class="cov0" title="0">{
        // Mensaje para nuestra regla personalizada 'not_in_bank_blacklist'.
        _ = validate.RegisterTranslation("not_in_bank_blacklist", trans, func(ut ut.Translator) error </span><span class="cov0" title="0">{
                return ut.Add("not_in_bank_blacklist", "El c√≥digo de entidad ingresado no est√° permitido.", true)
        }</span>, func(ut ut.Translator, fe validator.FieldError) string <span class="cov0" title="0">{
                t, _ := ut.T("not_in_bank_blacklist", fe.Field())
                return t
        }</span>)

        // Puedes sobrescribir otros mensajes por defecto si lo necesitas. Por ejemplo, para 'min':
        <span class="cov0" title="0">_ = validate.RegisterTranslation("min", trans, func(ut ut.Translator) error </span><span class="cov0" title="0">{
                return ut.Add("min", "El campo {0} debe tener al menos {1} caracteres.", true)
        }</span>, func(ut ut.Translator, fe validator.FieldError) string <span class="cov0" title="0">{
                t, _ := ut.T("min", fe.Field(), fe.Param())
                return t
        }</span>)
}

// validateRequest ejecuta la validaci√≥n y formatea los errores.
func validateRequest(req interface{}) (map[string][]string, bool) <span class="cov0" title="0">{
        err := validate.Struct(req)
        if err != nil </span><span class="cov0" title="0">{
                validationErrors := make(map[string][]string)
                for _, err := range err.(validator.ValidationErrors) </span><span class="cov0" title="0">{
                        fieldName := err.Field()
                        // Usamos el traductor para obtener el mensaje de error en espa√±ol.
                        message := err.Translate(trans)
                        validationErrors[fieldName] = append(validationErrors[fieldName], message)
                }</span>
                <span class="cov0" title="0">return validationErrors, false</span>
        }
        <span class="cov0" title="0">return nil, true</span>
}

// Validate es el middleware de Fiber que se usa en las rutas.
func Validate(req interface{}) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                // Creamos una nueva instancia del tipo de 'req' para cada petici√≥n
                // para evitar 'race conditions' con peticiones concurrentes.
                reqPointer := reflect.New(reflect.TypeOf(req).Elem()).Interface()

                if err := c.BodyParser(reqPointer); err != nil </span><span class="cov0" title="0">{
                        // Usamos el helper de respuesta para estandarizar el error.
                        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                                "status":  "error",
                                "message": "Cuerpo de la petici√≥n inv√°lido o malformado.",
                        })
                }</span>

                <span class="cov0" title="0">if errors, ok := validateRequest(reqPointer); !ok </span><span class="cov0" title="0">{
                        // Usamos el helper de respuesta para estandarizar el error de validaci√≥n.
                        return c.Status(fiber.StatusUnprocessableEntity).JSON(fiber.Map{
                                "status":  "error",
                                "message": "Los datos proporcionados no son v√°lidos.",
                                "errors":  errors,
                        })
                }</span>

                <span class="cov0" title="0">c.Locals("req", reqPointer)
                return c.Next()</span>
        }
}
</pre>

		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
