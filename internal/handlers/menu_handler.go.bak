package handlers

import (
	"go-fiber-core/internal/dtos/requests"
	"go-fiber-core/internal/dtos/responses"
	"go-fiber-core/internal/models"

	"log"

	fiber "github.com/gofiber/fiber/v2"
)

type MenuHandler interface {
	Create(c *fiber.Ctx) error
	SoftDelete(c *fiber.Ctx) error
	AddRoles(c *fiber.Ctx) error
	RemoveRoles(c *fiber.Ctx) error
	BulkAddRoles(c *fiber.Ctx) error
	BulkRemoveRoles(c *fiber.Ctx) error
}

type menuHandler struct {
	// writer menuService.MenuWriterService
	// reader    menuService.MenuReaderService
	// paginator menuService.MenuPaginationServicek

	// --- NUEVOS CAMPOS ---
	// apiService        menuService.MenuAPIService
	// serviceConfigServ menuService.MenuServiceConfigService
}

func NewMenuHandler(
// writer menuService.MenuWriterService,
// reader menuService.MenuReaderService,
// paginator menuService.MenuPaginationService,
// apiService menuService.MenuAPIService,
// serviceConfigServ menuService.MenuServiceConfigService,
) MenuHandler {
	return &menuHandler{
		writer: writer,
		// reader:            reader,
		// paginator:         paginator,
		// apiService:        apiService,
		// serviceConfigServ: serviceConfigServ,
	}
}
func (h *menuHandler) Create(c *fiber.Ctx) error {
	ctx := c.UserContext()

	userID, err := getUserIDUint64FromCtx(ctx)
	if err != nil {
		return responses.Error(c, fiber.StatusUnauthorized, "Error de autenticación", err)
	}
	log.Printf("Usuario %d está creando un menú", userID)

	var req requests.CreateMenuRequest
	if err := c.BodyParser(&req); err != nil {
		return responses.Error(c, fiber.StatusBadRequest, "Error al parsear el cuerpo de la solicitud", err)
	}

	// Creamos el modelo a guardar
	newMenu := models.Menu{
		ItemType: req.ItemType,
		ItemName: req.ItemName,
		Icon:     req.Icon,
		ToPath:   req.ToPath,
		ParentID: req.ParentID,
	}

	if err := h.writer.Create(ctx, &newMenu); err != nil {
		return responses.Error(c, fiber.StatusInternalServerError, "Error al crear el menú", err)
	}

	return responses.Success(c, "Menú creado exitosamente", newMenu)
}

func (h *menuHandler) SoftDelete(c *fiber.Ctx) error {
	ctx := c.UserContext()

	// AÑADIDO: Obtener el ID de usuario del contexto
	userID, err := getUserIDUint64FromCtx(ctx)
	if err != nil {
		return responses.Error(c, fiber.StatusUnauthorized, "Error de autenticación", err)
	}
	// ---

	id, err := getUintID(c) // Asumiendo que getUintID está en helpers.go
	if err != nil {
		return err
	}

	log.Printf("Usuario %d está borrando lógicamente el item %d", userID, id)

	if err := h.writer.SoftDelete(ctx, uint(id)); err != nil {
		return err
	}
	return responses.Success(c, "Item borrado lógicamente", nil)
}

func (h *menuHandler) AddRoles(c *fiber.Ctx) error {
	ctx := c.UserContext()

	menuID, err := getUintID(c)
	if err != nil {
		return err
	}

	// Usamos el DTO en lugar del struct anónimo
	var req requests.AddRolesRequest
	if err := c.BodyParser(&req); err != nil {
		return responses.Error(c, fiber.StatusBadRequest, "JSON inválido", err)
	}

	if len(req.RoleIDs) == 0 {
		return responses.Error(c, fiber.StatusBadRequest, "Debe incluir al menos un role_id", nil)
	}

	if err := h.writer.AddRoles(ctx, menuID, req.RoleIDs); err != nil {
		return responses.Error(c, fiber.StatusInternalServerError, "Error al asociar roles", err)
	}

	return responses.Success(c, "Roles asociados correctamente", nil)
}

func (h *menuHandler) RemoveRoles(c *fiber.Ctx) error {
	ctx := c.UserContext()

	menuID, err := getUintID(c)
	if err != nil {
		return err
	}

	var req struct {
		RoleIDs []uint64 `json:"role_ids"`
	}

	if err := c.BodyParser(&req); err != nil {
		return responses.Error(c, fiber.StatusBadRequest, "JSON inválido", err)
	}

	if len(req.RoleIDs) == 0 {
		return responses.Error(c, fiber.StatusBadRequest, "Debe incluir al menos un role_id", nil)
	}

	if err := h.writer.RemoveRoles(ctx, menuID, req.RoleIDs); err != nil {
		return responses.Error(c, fiber.StatusInternalServerError, "Error al eliminar roles del menú", err)
	}

	return responses.Success(c, "Roles desasociados correctamente", nil)
}

func (h *menuHandler) BulkAddRoles(c *fiber.Ctx) error {
	ctx := c.UserContext()

	var req requests.BulkAddRolesToMenusRequest
	if err := c.BodyParser(&req); err != nil {
		return responses.Error(c, fiber.StatusBadRequest, "JSON inválido", err)
	}

	if len(req.MenuIDs) == 0 || len(req.RoleIDs) == 0 {
		return responses.Error(c, fiber.StatusBadRequest, "Debe incluir menu_ids y role_ids", nil)
	}

	if err := h.writer.BulkAddRoles(ctx, req.MenuIDs, req.RoleIDs); err != nil {
		return responses.Error(c, fiber.StatusInternalServerError, "Error al asociar roles a menús", err)
	}

	return responses.Success(c, "Roles asociados correctamente a los menús", nil)
}

func (h *menuHandler) BulkRemoveRoles(c *fiber.Ctx) error {
	ctx := c.UserContext()

	var req requests.BulkAddRolesToMenusRequest
	if err := c.BodyParser(&req); err != nil {
		return responses.Error(c, fiber.StatusBadRequest, "JSON inválido", err)
	}

	if len(req.MenuIDs) == 0 || len(req.RoleIDs) == 0 {
		return responses.Error(c, fiber.StatusBadRequest, "Debe incluir menu_ids y role_ids", nil)
	}

	if err := h.writer.BulkRemoveRoles(ctx, req.MenuIDs, req.RoleIDs); err != nil {
		return responses.Error(c, fiber.StatusInternalServerError, "Error al eliminar roles de menús", err)
	}

	return responses.Success(c, "Roles eliminados correctamente de los menús", nil)
}
